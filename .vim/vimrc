" {{{1 vim: filetype=vim:
" AUTHOR: Zach Fogg <me@zfo.gg>
" DEPENDS:
"   VIM:      >= 7.4
"   VIMPAGER: >= 2.06
"   NEOVIM:   >= 0.1.5
" }}}1 `modeline`


" {{{1 META: pre
    "filetype off
    "filetype plugin indent off
    " {{{2 config paths
            " s:mvvar =~# escape('s:\i+(_(l|f|r))?', '+()|?')
                " s:myvar_l  (l)ocal path basename
                " s:myvar_f  (f)ully resolved links (expanded vars)
                " s:myvar_r  (r)elative to $HOME (un-expanded vars)
        " dir/ ~/.dotfiles/ 's:dotfiles'
        let s:dotfiles_l = '.dotfiles'
        let s:dotfiles   = fnamemodify(exists('$DOTFILES') ? $DOTFILES : s:dotfiles_l, ':~')
        let s:dotfiles_f = expand(s:dotfiles)
        let s:dotfiles_r = fnamemodify(s:dotfiles, ':~')
        " dir/ ~/.vim/ 's:dotvim'
        let s:dotvim_l   = '.vim'
        let s:dotvim     = exists('$DOTVIM')               ? $DOTVIM   : s:dotfiles.'/'.s:dotvim_l
        let s:dotvim_f   = expand(s:dotvim)
        let s:dotvim_r   = fnamemodify(s:dotvim,   ':~')
        " file ~/.vimrc 's:myvimrc'
        let s:myvimrc_l = 'vimrc'
        let s:myvimrc   = s:dotvim  .'/'.s:myvimrc_l
        let s:myvimrc_f = s:dotvim_f.'/'.s:myvimrc_l
        let s:myvimrc_r = s:dotvim_r.'/'.s:myvimrc_l
    " }}}2 config paths
" }}}1 META: pre


" {{{1 Basic Settings
    set number numberwidth=3    " hybrid line numbers - relative & static
    set title                   " file title in the $TERM titlebar
    set showtabline=1           " show buffer tabs when more than `n`
    set pastetoggle=<F1>        " for 'Insert' mode pasting with <S-Insert>
    set history=8192            " persist mode-cmdline history
    set noerrorbells visualbell " no system bell, no screen blink on error
    set wildmenu                " custom completion menu
    set wildmode=
        \longest:full,
        \list:full

    let g:netrw_dirhistmax=0 " http://www.vim.org/scripts/script.php?script_id=1075

    " {{{2 undo / redo, swap, backup
        let s:dotvim_dotdirs = {}
        for [s:dir_name, s:dir_path] in items({
            \ 'undo'   : '.undo',
            \ 'swap'   : '.swap',
            \ 'backup' : '.backup',
        \ })
            let s:dir = s:dotvim_f.'/'.s:dir_path
            if !isdirectory(s:dir) | call mkdir(s:dir) | endif
            let s:dotvim_dotdirs[s:dir_name] = s:dir[1:]
        endfor

        if !exists('g:mytmpdir')
            let g:mytmpdir = system('echo -n "${TMPDIR%/}"')
        endif

        function! MyTmpdirs(pree, post, ...)
            let l:pree = exists('a:pree') ? a:pree : ''
            let l:post = exists('a:post') ? a:post : ''
            let l:pre_dirs = a:0 > 0
                \ ? map(copy(a:000), 'l:pree . v:val . l:post')
                \ : []
            let l:std_dirs = [
                \          g:mytmpdir    . l:post,
                \ l:pree . 'private/tmp' . l:post,
                \ l:pree . 'var/tmp'     . l:post,
                \ l:pree . 'tmp'         . l:post,
            \ ]
            let l:out_dirty = join(l:pre_dirs + l:std_dirs, ',')
            return escape(l:out_dirty, '\')
        endfunction

        " wildignore
        set wildignore+=*.o,*.obj,*.so,,*.exe,*.dll,*.manifest,*.dmg
        set wildignore+=*.swp,*.pyc,*.class
        set wildignore+=*.tar,*.bz,*.gz,*.xz,*.zip
        set wildignore+=*~

        " {un,re}do history
        let &undodir = MyTmpdirs('/', '', s:dotvim_dotdirs['undo'])
        set undofile

        " swapfiles
        let &directory = MyTmpdirs('/', '//', s:dotvim_dotdirs['swap'])

        " backups
        let &backupdir  = MyTmpdirs('/', '', s:dotvim_dotdirs['backup'])
        let &backupskip = MyTmpdirs('/', '/*',
            \ s:dotvim_dotdirs['undo'],
            \ s:dotvim_dotdirs['swap'],
            \ s:dotvim_dotdirs['backup'],
        \ )
        set backupskip=&backupskip
    " }}}2 undo / redo, swap, backup

    " {{{2 Moving around and editing
        set nostartofline   " Avoid moving cursor to BOL when jumping around.
        set virtualedit=all " Let cursor move past $ in command mode.
        set backspace=2     " Allow backspacing over autoindent, EOL, and BOL.
        set autoindent      " Always set autoindenting on.
        set lazyredraw      " For better macro performance.
    " }}}2 Moving around and editing

    " {{{2 Tiny aesthetic tweaks
        set cursorline      " A horizontal line for the cursor location.
        set ruler           " Show the cursor position all the time.
        set scrolloff=5     " Keep n context lines above and below the cursor.
        set sidescrolloff=9 " a
        set sidescroll=1    " b
        set showmatch       " Briefly jump to a paren once it's balanced.
        set list            " Visually display tabs and trailing whitespace.
        set listchars=
            \eol:¬¨,
            \tab:‚Üí\ ,
            \trail:¬∑,
            \extends:‚ü©,
            \precedes:‚ü®,
            \nbsp:‚ê£
    " }}}2 Tiny aesthetic tweaks

    " Whitespace {{{2
        set expandtab       " Use spaces, not tabs, for autoindent/tab key.
        set copyindent
        set preserveindent
        set softtabstop=4   " <BS> over an autoindent deletes both spaces.
        set shiftwidth=4    " An indent level is n spaces.
        set tabstop=4       " <Tab> inserts n spaces.
        set shiftround      " Rounds indent to a multiple of shiftwidth.
        set nowrap          " Don't wrap text.
        set linebreak       " Don't wrap textin the middle of a word.
        set wrapmargin=0    " Seriously, don't break lines.
        set textwidth=0     " Don't break lines.
        set showbreak=‚Ü™\    " Visualize wrapped lines.
    " }}}2

    " Folding. {{{2
        set foldmethod=syntax
        set foldopen=mark,percent,quickfix,tag,undo
        set foldenable
    " }}}2

    " Reading and writing. {{{2
        set noautowrite      " Never write a file unless I request it.
        set noautowriteall   " NEVER.
        set noautoread       " Don't automatically re-read changed files.
        set modeline         " Allow vim options to be embedded in files;
        set modelines=3      " they must be within the first or last 5 lines.
        set ffs=unix,dos,mac " Try recognizing dos, unix, and mac line endings.
    " }}}2

    " Messages, info, and statuses. {{{2
        set shortmess=aOstTI " :help 'shortmess'
        set laststatus=2     " allways show status line
        set confirm          " Y-N-C prompt if closing with unsaved changes.
        set showcmd          " Show incomplete normal mode commands as I type.
        set report=0         " : commands always print changed line count.
        set ruler            " Show some info, even without statuslines.
        set laststatus=2     " Always show statusline, even if only 1 window.
        "set statusline=%<%f\ %h%m%r%{fugitive#statusline()}%=%-14.(%l,%c%V%)\ %P
    " }}}2

    " Searching and Patterns {{{2
        set ignorecase " Default to using case insensitive searches.
        set smartcase  " unless uppercase letters are used in the regex.
        set smarttab   " Handle tabs more intelligently.
        set hlsearch   " Highlight searches by default.
        set incsearch  " Incrementally search while typing a /regex.
    " }}}2

    " The 'Session' plugin does this on save.
    set sessionoptions-=blank
    set sessionoptions-=buffers

    " Per-project .vimrc.
    set exrc secure

    " Faster CursorHold aucmd
    set updatetime=180 " milliseconds

    " 'text-obj' patterns for 'word' and file /path
        " NOTE: http://www.ascii-code.com/
            " '@'       == /[a-zA-Z]/ == filter(isalpha, $ascii_arr)
            " ,48-57,   == /[0-9]/    == filter(isdigit, $ascii_arr)
            " ,192-255, == /[√Ä-√ø]/    /* accented characters - extended ascii */
            " ,,,       == /,/
            " ,@-@,     == /@/
            " ,^,,      == /[^,]/
            " ,^<EOL>   == /\^/
        " NOTE: :h 'isfname' | :help 'iskeyword'
    set   isfname=@,48-57,_,#,~,$,-,/,.,+,,,%,=
    set iskeyword=@,48-57,_,192-255
" }}}1 Basic Settings


" Key Mappings {{{1
    let mapleader=","

    inoremap <C-c> <Esc>

    noremap : <Nop>
    noremap ; :
    " and if you ever wanna map to ;
    "noremap ;; ;

    " write
    nnoremap <Leader>w :w<CR>
    nnoremap <Leader>W :sil! w<CR>
    cnoremap w! w !sudo tee % >/dev/null

    " quit
    nnoremap <Leader>q :q<CR>

    " vimrc
    exe 'nn <silent> <Leader>v :'
        \.'cd '.s:dotvim_r             .' <Bar> '
        \.'$tabe! '.s:myvimrc_l        .' <Bar> '
        \.'cd -'                       .' <Bar> '
        \.'exe "norm! zvzz"'           .' <Bar> '
        \.'<CR>'
    exe 'nn <silent> <Leader>V :'
        \.'cd '.s:dotvim_r             .' <Bar> '
        \.'so '.s:myvimrc_l            .' <Bar> '
        \.'cd -'                       .' <Bar> '
        \.'filet detect'               .' <Bar> '
        \.'exe "norm! zvzz"'           .' <Bar> '
        \.'<CR>'

    " Disabled default commands. {{{2
        nnoremap Q       <Nop>
        noremap  <Up>    <Nop>
        noremap  <Down>  <Nop>
        noremap  <Left>  <Nop>
        noremap  <Right> <Nop>
        inoremap <Up>    <Nop>
        inoremap <Down>  <Nop>
        inoremap <Left>  <Nop>
        inoremap <Right> <Nop>
    " }}}2

    " Yanking and pasting. {{{2
        " Copy to system clipboard.
        noremap <Leader>y "+y
        " Paste from system clipboard.
        noremap <Leader>p "+p
        " Easily yank from cursor to EOL.
        nnoremap Y y$
        " Retain " register after pasting.
        xnoremap <expr> p v:register=='"'?'pgvy':'p'
    " }}}2

    " Cursor motion. {{{2
        if empty($TMUX)
            nnoremap <C-H> <C-W>h
            nnoremap <C-J> <C-W>j
            nnoremap <C-K> <C-W>k
            nnoremap <C-L> <C-W>l
        else
            let g:tmux_navigator_no_mappings = 1
            nnoremap <silent> <C-h> :TmuxNavigateLeft<CR>
            nnoremap <silent> <C-j> :TmuxNavigateDown<CR>
            nnoremap <silent> <C-k> :TmuxNavigateUp<CR>
            nnoremap <silent> <C-l> :TmuxNavigateRight<CR>
            nnoremap <silent> <C-\> :TmuxNavigatePrevious<CR>
        end
        if has('nvim')
            let $NVIM_TUI_ENABLE_CURSOR_SHAPE = 1          " change cursor to bar in insert mode
            tnoremap <Esc> <C-\><C-n>
            tmap     <silent> jj <C-\><C-n>{}k$
            tmap     <silent> <C-h> jj<C-h>
            tmap     <silent> <C-j> jj<C-j>
            tmap     <silent> <C-k> jj<C-k>
            tmap     <silent> <C-l> jj<C-l>
        end

        " j and k just work on long wrapped lines.
        nnoremap j gj
        nnoremap k gk

        " Scroll through items in the locations list.
        nmap <Leader>< <Plug>LocationPrevious
        nmap <Leader>> <Plug>LocationNext

        " A 'scrolling' effect.
        " FIXME: doesn't really work with in my iTerm+tmux setup.
        " nnoremap <a-j> <c-e>j
        " nnoremap <a-k> <c-y>k
        " nnoremap <a-l> zll
        " nnoremap <a-h> zhh

        " think of your left pinky
        inoremap jj    <Esc>
        inoremap kk    <Esc>:w<CR>

        " Leaving `Insert-mode` is too much sometimes.
        inoremap HH <C-o>^
        inoremap LL <C-o>$

        " Jump to matching pairs easily with tab.
        vnoremap <Tab> %
    " }}}2

    " Folds. {{{2
        nnoremap <Space> za
        vnoremap <Space> za
    " }}}2

    " Tabs and splits. {{{2
        nnoremap <Leader><C-t> :tabnew<CR>
        nnoremap <Leader>x     :tabclose<CR>
        nnoremap <Leader>j     :tabprevious<CR>
        nnoremap <Leader>k     :tabnext<CR>
        " Resize splits.
        nnoremap <S-Up>    5<C-W>+
        nnoremap <S-Down>  5<C-W>-
        nnoremap <S-Right> 5<C-W>>
        nnoremap <S-Left>  5<C-W><
        nnoremap   <Up>     <C-W>+
        nnoremap   <Down>   <C-W>-
        nnoremap   <Right>  <C-W>>
        nnoremap   <Left>   <C-W><
    " }}}2

    " :make. {{{2
        "nnoremap <Leader>M  :silent! make<CR>:redraw!<CR>
        "nnoremap <Leader>Mc :silent! make clean<CR>:redraw!<CR>
        "nnoremap <Leader>Mm :silent! make clean all<CR>:redraw!<CR>
        "nnoremap <Leader>Mt :cclose \| silent! make test           \| copen<CR>:AnsiEsc<CR>G:redraw!<CR>
        "nnoremap <Leader>MT :cclose \| silent! make clean all test \| copen<CR>:AnsiEsc<CR>G:redraw!<CR>
    " }}}

    " Et cetera. {{{2
        " Previous matching command or search.
        cnoremap kk <Up>

        " Enter Replace mode from Visual mode.
        vnoremap R r<Space>R

        " Don't let `single-repeat` disturb the cursor's location.
        nnoremap . .`[

        " Delete trailing whitespace.
        nnoremap <Leader>S :%s/\s\+$//<CR>:let @/=''<CR><c-o>

        " Fixes for display glitches.
        nnoremap <silent> <Leader><Space> :nohlsearch<C-R>=has('diff')?'<Bar>diffupdate':''<CR><CR>,<Space>
        nnoremap <Leader>rd :redraw!<CR>

        " Set the background to transparent.
        "nnoremap <Leader>bg :hi Normal ctermbg=NONE<CR>

        " Change to the directory of the current buffer's file.
        nnoremap <Leader>lcd :lcd %:p:h<BAR>pwd<CR>
        nnoremap <Leader>cd  :cd  %:p:h<BAR>pwd<CR>

        " omnicomplete
        "imap </            <C-_>
        "nnoremap <Leader>/ <C-_>
    " }}}2
" Key Mappings }}}1


" Plugin Settings {{{1
    " NERDTree {{{2
        let NERDTreeWinPos                    = "left"
        let NERDTreeAutoCenter                = 1
        let NERDTreeCaseSensitiveSort         = 0
        let NERDTreeHighlightCursorline       = 1
        let NERDTreeBookmarksFile             = s:dotvim_f.'.cache/NERDTree.bookmarks'
        let NERDTreeMouseMode                 = 2
        let NERDTreeShowHidden                = 1
        let NERDTreeMinimalUI                 = 1
        let NERDTreeHijackNetrw               = 1
        let NERDTreeRespectWildIgnore         = 1
        let NERDTreeCascadeOpenSingleChildDir = 2
        let NERDTreeAutoDeleteBuffer          = 1
        "let NERDTreeChDirMode                 = 2
        let NERDTreeWinSize                   = 24

        let NERDTreeCreatePrefix = 'silent keepa keepj keepp keepm'

        let NERDTreeIgnore    = [ '\~$' ,
            \ '' . '.git'             . '$' . '[[dir]]'  ,
            \ '' . '.hg'              . '$' . '[[dir]]'  ,
            \ '' . '.svn'             . '$' . '[[dir]]'  ,
            \ '' . 'node_modules'     . '$' . '[[dir]]'  ,
            \ '' . 'bower_components' . '$' . '[[dir]]'  ,
            \ ''  . '.o'              . '$' . '[[file]]' ,
            \ ''  . '.obj'            . '$' . '[[file]]' ,
            \ ''  . '.so'             . '$' . '[[file]]' ,
            \ ''  . '.exe'            . '$' . '[[file]]' ,
            \ ''  . '.dmg'            . '$' . '[[file]]' ,
            \ ''  . '.swap'           . '$' . '[[file]]' ,
            \ ''  . '.class'          . '$' . '[[file]]' ,
            \ ''  . '.pyc'            . '$' . '[[file]]' ,
            \ ''  . '.tar'            . '$' . '[[file]]' ,
            \ ''  . '.bz'             . '$' . '[[file]]' ,
            \ ''  . '.gz'             . '$' . '[[file]]' ,
            \ ''  . '.xz'             . '$' . '[[file]]' ,
            \ ''  . '.zip'            . '$' . '[[file]]' ,
            \ ''  . '.DS_Store'       . '$' . '[[file]]' ,
            \ ''  . '%'               . ''  . '[[file]]' ,
        \ ]

        " command - toggle
        func! <SID>MyNERDTreeToggle()
            if exists('t:NERDTreeBufName')
                if exists('g:zNTOn') || &buftype != ''
                    unlet! g:zNTOn
                    NERDTreeClose
                    return
                else
                    NERDTree
                endif
            else
                NERDTree %:p:h
            endif
            let g:zNTOn = 1
            wincmd p
        endfunc
        nnoremap <silent> <Leader>n<Space> :call <SID>MyNERDTreeToggle()<CR>

        " autocommand - auto-cwd (BufEnter *)
        func! <SID>MyNERDTreeAutoCWD()
            if exists("b:noNERDTreeAutoCWD")
                return
            elseif exists("g:zNTOn")
                "cd %:p:h
                "NERDTreeCWD
                "wincmd p
            endif
        endfunc

        aug <SID>MyNERDTree
            au!
            "au BufEnter      * silent! call <SID>MyNERDTreeAutoCWD()
            "au TabNew * call <SID>MyNERDTreeToggle()
        aug END
    " }}}2

    " NERDCommenter {{{2
        let NERDMenuMode               = 1
        let NERDSpaceDelims            = 0
        let NERDRemoveExtraSpaces      = 1
        let NERDCompactSexyComs        = 1
        let NERDAlignDefault           = "both"
        let NERDTrimTrailingWhitespace = 1
        " `&filetype` settings
        let g:NERDAltDelims_haskell    = 1
    " }}}2

    " Fugitive. {{{2
        " key bindings
        nmap <Leader>gc :Gcommit<CR>
        nmap <Leader>gd :Gdiff<CR>
        nmap <Leader>gl :Glog<CR>
        nmap <Leader>gs :Gstatus<CR>
        nmap <Leader>gR :Gread<CR>
        nmap <Leader>gW :Gwrite<CR>:e<CR>
        nmap <Leader>gp :Git push<CR>
        nmap <Leader>gb :Gblame<CR>
        nmap <Leader>gH :Gbrowse<CR>
    " }}}2

    " IndentGuides {{{2
        let g:indent_guides_start_level           = 2
        let g:indent_guides_guide_size            = 1
        let g:indent_guides_enable_on_vim_startup = 1
        let g:indent_guides_auto_colors           = 0
        function! <SID>SetIndentGuideColors()
            hi clear IndentGuidesOdd
            hi clear IndentGuidesEven
            hi IndentGuidesOdd  ctermbg=19 guibg=#383838
            hi IndentGuidesEven ctermbg=08 guibg=#585858
        endfunction
        augroup IndentGuides
            au!
            au! VimEnter,Colorscheme * :call <SID>SetIndentGuideColors()
        augroup END
    " }}}2

    " Rainbow Parentheses {{{2
        let g:rainbow_active = 1
        let g:rainbow_conf = {
            \ 'operators': '_,_',
            \ 'parentheses': [
                \ 'start=/(/  end=/)/  fold',
                \ 'start=/\[/ end=/\]/ fold',
                \ 'start=/{/  end=/}/  fold',
            \ ],
            \ 'guifgs': [
                \ 'royalblue3',
                \ 'darkorange3',
                \ 'seagreen3',
                \ 'firebrick',
            \ ],
            \ 'ctermfgs': [
                \ 'lightblue',
                \ 'lightyellow',
                \ 'lightcyan',
                \ 'lightmagenta',
            \ ],
            \ 'separately': {
                \ '*': {},
                \ 'css': 0,
                \ 'phony.example': {
                    \ 'operators'   : '',
                    \ 'parentheses' : [],
                    \ 'guifgs'      : [],
                    \ 'ctermfgs'    : [],
                \ },
                \ 'vim': {
                    \ 'parentheses': [
                        \ 'start=/(/  end=/)/',
                        \ 'start=/\[/ end=/\]/',
                        \ 'start=/{/  end=/}/  fold',
                        \ 'start=/(/  end=/)/       containedin=vimFuncBody',
                        \ 'start=/\[/ end=/\]/      containedin=vimFuncBody',
                        \ 'start=/{/  end=/}/  fold containedin=vimFuncBody',
                    \ ],
                \ },
                \ 'html': {
                    \ 'parentheses': [
                        \ 'start=/\v\<((area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)[ >])@!\z([-_:a-zA-Z0-9]+)(\s+[-_:a-zA-Z0-9]+(\=("[^"]*"|'."'".'[^'."'".']*'."'".'|[^ '."'".'"><=`]*))?)*\>/ end=#</\z1># fold'
                    \ ],
                \ },
            \ }
        \ }
        " key bindings
        "nnoremap <Leader>rp<Space> :RainbowParenthesesToggleAll<CR>
    " }}}2

    " SuperTab {{{2
        let g:SuperTabDefaultCompletionType = '<c-n>'
    " }}}2

    " deoplete {{{2
        let g:deoplete#enable_at_startup           = 1 " just work
        let g:deoplete#enable_smart_case           = 1 " smartcase
        "let g:deoplete#sources#clang#libclang_path = '/Library/Developer/CommandLineTools/usr/lib/libclang.dylib'
        "let g:deoplete#sources#clang#clang_header  = '/Library/Developer/CommandLineTools/usr/lib/clang'
        let g:deoplete#sources#clang#libclang_path = '/usr/local/opt/llvm/lib/libclang.dylib'
        let g:deoplete#sources#clang#clang_header  = '/usr/local/opt/llvm/lib/clang'
    " }}}2

    " Ag {{{2
        if executable('ag')
            let g:ag_prg    = 'ag --vimgrep --nogroup --hidden -p '.$HOME.'/.agignore $*'
            let &grepprg    = g:ag_prg
            let &grepformat = '%f:%l:%c:%m'
        else
            let &grepprg = 'grep --color=never -e --exclude-dir .git -nrI $* . /dev/null'
        endif
    " Ag }}}2

    " CtrlP {{{2
        let g:ctrlp_map               = '<C-p>'
        let g:ctrlp_cmd               = 'CtrlP'
        let g:ctrlp_root_markers      = ['.git',  '.hg', '.svn']
        let g:ctrlp_working_path_mode = 'ra'
        let g:ctrlp_cache_dir         = s:dotvim_f.'/.cache/ctrlp'
        let g:ctrlp_extensions        = ['mixed', 'tag', 'line', 'dir', 'commandline']
        let g:ctrlp_custom_ignore = {
          \ 'dir':  '\v[\/]\.(git|hg|svn)$',
          \ 'file': '\v\.(exe|so|dll)$',
          \ 'link': 'SOME_BAD_SYMBOLIC_LINKS',
          \ }
        let g:ctrlp_user_command = {
            \ 'types': {
                \ 1: ['.git', 'cd %s && git ls-files -co --exclude-standard'],
            \ },
        \ }
        " key bindings
        "nmap <C-p> <Plug>CtrlP
        "nmap <C-f> <Plug>CtrlPLine
    " }}}2

    " {{{2 EasyMotion
        "let g:EasyMotion_leader_key = '<Leader>'
        "nnoremap <Leader><Leader> <Plug>(easymotion-prefix)
    " }}}2 EasyMotion

    " EasyAlign{{{2
        nmap ga <Plug>(EasyAlign)
        xmap ga <Plug>(EasyAlign)
        let g:easy_align_ignore_groups          = ['Comment', 'String']  "[]
        let g:easy_align_interactive_modes      = ['l', 'r', 'c']        "['l', 'r', 'c']
        let g:easy_align_bang_interactive_modes = ['r', 'l', 'c']        "['r', 'l', 'c']
    " }}}2

    " Lightline {{{2
        let g:lightline = {
            \ 'colorscheme': 'jellybeans',
            \ 'separator'    : { 'left': 'ÓÇ∞', 'right': 'ÓÇ≤' },
            \ 'subseparator' : { 'left': 'ÓÇ±', 'right': 'ÓÇ≥' },
            \ 'active': {
                \ 'left': [
                    \ ['mode', 'paste'],
                    \ ['fugitive', 'filename'],
                    \ ['ctrlpmark'],
                \ ],
                \ 'right': [
                    \ ['percent'],
                    \ ['fileformat', 'fileencoding', 'filetype'],
                \ ],
            \ },
            \ 'component_function': {
                \ 'readonly'     : 'LightLineReadonly',
                \ 'modified'     : 'LightLineModified',
                \ 'fugitive'     : 'LightLineFugitive',
                \ 'filename'     : 'LightLineFilename',
                \ 'fileformat'   : 'LightLineFileformat',
                \ 'filetype'     : 'LightLineFiletype',
                \ 'fileencoding' : 'LightLineFileencoding',
                \ 'mode'         : 'LightLineMode',
                \ 'ctrlpmark'    : 'CtrlPMark',
            \ },
        \ }

        function! LightLineReadonly()
            if &ft == 'help' | return ''
            elseif &readonly | return 'üîí'
            else             | return '' | endif
        endfunction

        function! LightLineModified()
            if &ft == 'help'   | return ''
            elseif &modified   | return '+'
            elseif &modifiable | return '-'
            else               | return '' | endif
        endfunction

        function! LightLineFugitive()
            try
                if expand('%:t') !~? 'Tagbar\|Gundo\|NERD' && &ft !~? 'vimfiler' && exists('*fugitive#head')
                let branch = fugitive#head()
                return branch !=# '' ? 'ÓÇ† ' . branch : ''
                endif
            catch
            endtry
            return ''
        endfunction

        function! LightLineFilename()
            let fname = expand('%:t')
            if fname == 'ControlP' && has_key(g:lightline, 'ctrlp_item')
                return g:lightline.ctrlp_item
            elseif fname =~ 'NERD_tree' | return ''
            else
                return ('' != LightLineReadonly() ?       LightLineReadonly() . ' ' : '') .
                    \  ('' != fname ? expand('%:h:t').'/'.fname : '[No Name]') .
                    \  ('' != LightLineModified() ? ' ' . LightLineModified()       : '')
            endif
        endfunction

        function! LightLineFileformat()
            return winwidth(0) > 70 ? &fileformat : ''
        endfunction

        function! LightLineFiletype()
            return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
        endfunction

        function! LightLineFileencoding()
            return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
        endfunction

        function! LightLineMode()
            let fname = expand('%:t')
            return fname == 'ControlP' ? 'CtrlP' :
                \ fname =~ 'NERD_tree' ? 'NERDTree' :
                \ winwidth(0) > 60 ? lightline#mode() : ''
        endfunction

        function! CtrlPMark()
            if expand('%:t') =~ 'ControlP' && has_key(g:lightline, 'ctrlp_item')
                call lightline#link('iR'[g:lightline.ctrlp_regex])
                return lightline#concatenate([
                    \ g:lightline.ctrlp_prev,
                    \ g:lightline.ctrlp_item,
                    \ g:lightline.ctrlp_next,
                \ ], 0)
            else | return '' | endif
        endfunction

        let g:ctrlp_status_func = {
            \ 'main': 'CtrlPStatusFunc_1',
            \ 'prog': 'CtrlPStatusFunc_2',
        \ }
        function! CtrlPStatusFunc_1(focus, byfname, regex, prev, item, next, marked)
            let g:lightline.ctrlp_regex = a:regex
            let g:lightline.ctrlp_prev  = a:prev
            let g:lightline.ctrlp_item  = a:item
            let g:lightline.ctrlp_next  = a:next
            return lightline#statusline(0)
        endfunction
        function! CtrlPStatusFunc_2(str)
            return lightline#statusline(0)
        endfunction
    " }}}2

    " Neomake {{{2
        hi link NeomakeErrorSign   NeomakeErrorSignDefault
        hi link NeomakeWarningSign NeomakeWarningSignDefault
        augroup Neomake
            autocmd!
            " autocmd ColorScheme *
                " \ hi NeomakeErrorSign   ctermfg=red    guifg=red |
                " \ hi NeomakeWarningSign ctermfg=yellow guifg=yellow
            " autocmd! BufWritePost * Neomake
        augroup END
    " }}}2

    " Chromatica {{{2
        let g:chromatica#libclang_path=$BREW.'/opt/llvm/lib'
    " }}}2

    " Session {{{2
        let g:session_default_name      = 'default'           " When you don't name your session.
        let g:session_command_aliases   = 1                   " Use commands prefixed with 'Session'.
        let g:session_autosave          = 'yes'               " Save on exit sans prompt.
        let g:session_autosave_periodic = 2                   " Save every 'n' minutes.
        let g:session_autoload          = 0                   " Don't ask to open default session.
        let g:session_verbose_messages  = 0                   " Disable noisy save messages.
        let g:session_persist_globals   = ['&sessionoptions'] " Persist `vim-session` plugin opts
        call add(g:session_persist_globals, 'g:session_autosave')
        call add(g:session_persist_globals, 'g:session_autosave_periodic')
        call add(g:session_persist_globals, 'g:session_autoload')
        call add(g:session_persist_globals, 'g:session_default_to_last')
        call add(g:session_persist_globals, 'g:session_persist_globals')
        nnoremap <Leader>So :OpenSession<CR>
        nnoremap <Leader>Ss :SaveSession<CR>
        nnoremap <Leader>Sq :SaveSession<CR>:CloseSession<CR>
        nnoremap <Leader>SQ <Leader>Sq:q<CR>
    " }}}2

    " gitgutter {{{2
        let g:gitgutter_enabled         = 1
        let g:gitgutter_map_keys        = 1
        let g:gitgutter_highlight_lines = 0
        let g:gitgutter_async           = 1
        let g:gitgutter_realtime        = 1
        let g:gitgutter_eager           = 1
        let g:gitgutter_diff_args       = '-w'
        let g:gitgutter_max_signs       = 1024
        "let g:gitgutter_grep_command    = &grepprg
        " key bindings
        nnoremap <Leader>gg<Space>  :GitGutterToggle<CR>
        nnoremap <Leader>ggl<Space> :GitGutterLineHighlightsToggle<CR>
        nmap             -          <Plug>GitGutterPrevHunk
        nmap             =          <Plug>GitGutterNextHunk
        nmap     <Leader>ggw        <Plug>GitGutterStageHunk
        nmap     <Leader>ggu        <Plug>GitGutterUndoHunk
        nmap     <Leader>ggd        <Plug>GitGutterPreviewHunk
        " replace the `=` mapping
        nnoremap <Leader>=          =
    " }}}2

    " editorconfig-vim {{{2
        let g:EditorConfig_exec_path = $BREW . '/bin/editorconfig'
    " }}}2

    " go {{{2
        let g:go_auto_type_info      = 1
        let g:go_highlight_operators = 1
        let g:go_highlight_functions = 1
        let g:go_highlight_methods   = 1
        let g:go_highlight_structs   = 1
    " }}}2

    " quick-scope {{{2
        "let g:qs_enable = 0
        "nnoremap <C-_> :normal ,<CR>
        "vnoremap <C-_> :normal ,<CR>
        "function! Quick_scope_selective(movement)
            "let needs_disabling = 0
            "if !g:qs_enable
                "QuickScopeToggle
                "redraw
                "let needs_disabling = 1
            "endif
            "let letter = nr2char(getchar())
            "if needs_disabling
                "QuickScopeToggle
            "endif
            "return a:movement . letter
        "endfunction
        " key bindings
        "nnoremap <expr> <silent> f Quick_scope_selective('f')
        "nnoremap <expr> <silent> F Quick_scope_selective('F')
        "nnoremap <expr> <silent> t Quick_scope_selective('t')
        "nnoremap <expr> <silent> T Quick_scope_selective('T')
        "vnoremap <expr> <silent> f Quick_scope_selective('f')
        "vnoremap <expr> <silent> F Quick_scope_selective('F')
        "vnoremap <expr> <silent> t Quick_scope_selective('t')
        "vnoremap <expr> <silent> T Quick_scope_selective('T')
    " }}}2

    " neoterm {{{2
        if has('nvim')
            let test#strategy      = "neoterm"  " run tests with :T
            let g:neoterm_position = "vertical" " vertical split
        endif
    " }}}2

    " plasticboy/vim-markdown {{{2
        if has('nvim')
            let g:markdown_fold_style             = 'nested'
            let g:markdown_fold_override_foldtext = 0
        endif
    " plasticboy/vim-markdown }}}2
" Plugin Settings }}}1


" Plugins {{{1
    call plug#begin('~/.vim/bundle')

    function! PIf(cond, ...)
        let opts = get(a:000, 0, {})
        return a:cond ? opts : extend(opts, { 'on': [], 'for': [] })
    endfunction

    " integrate with other programs {{{2
        Plug 'Shougo/vimproc.vim', { 'do': 'make' }
        Plug 'rking/ag.vim', PIf(executable('ag'), { 'on': 'Ag' })
        Plug 'rizzatti/dash.vim'
        Plug 'tpope/vim-fugitive'
        Plug 'airblade/vim-gitgutter'
        Plug 'tmux-plugins/vim-tmux', { 'for': 'tmux' }
        Plug 'tmux-plugins/vim-tmux-focus-events', PIf(executable('tmux') && !empty($TMUX))
        Plug 'christoomey/vim-tmux-navigator',     PIf(executable('tmux') && !empty($TMUX))
    " }}}2

    " Add features and functionality. {{{2
        Plug 'easymotion/vim-easymotion'
        Plug 'scrooloose/nerdtree'                                                                                                 |
            \Plug 'Xuyuanp/nerdtree-git-plugin'                                                                                    |
            \Plug 'taiansu/nerdtree-ag'
        Plug 'xolox/vim-misc'                                                                                                      |
            \Plug 'xolox/vim-session'
        Plug 'neomake/neomake', PIf(has('nvim'),                 { 'do': 'npm i -g vimlint'                                     }) |
            \Plug 'Shougo/neoinclude.vim'
        Plug 'ervandew/supertab'                                                                                                   |
            \Plug 'Shougo/deoplete.nvim', PIf(has('nvim'),       { 'do': ':UpdateRemotePlugins'                                 }) |
            \Plug 'Shougo/neco-vim',                             { 'for': ['vim']                                               }  |
            \Plug 'eagletmt/neco-ghc',    PIf(executable('ghc'), { 'for': ['haskell']                                           }) |
            \Plug 'zchee/deoplete-zsh',                          { 'for': ['zsh']                                               }  |
            \Plug 'zchee/deoplete-go',                           { 'for': ['go']                                                }  |
            \Plug 'zchee/deoplete-clang',                        { 'for': ['c', 'cpp', 'objc', 'objcpp']                        }  |
            \Plug 'carlitux/deoplete-ternjs',                    {
                \'for' : ['javascript'],
                \'do'  : 'npm install -g tern',
            \}
    " }}}2

    " Language support. {{{2
        "let g:polyglot_disabled = ['javascript']
        Plug 'gisphm/vim-gitignore'
        Plug 'sheerun/vim-polyglot'
        Plug 'applescript.vim',                              { 'for': ['applescript', 'osascript']               }
        Plug 'guns/vim-clojure-highlight',                   { 'for': ['clojure']                                }
        Plug 'saltstack/salt-vim',                           { 'for': ['sls']                                    }
        Plug 'mxw/vim-jsx',                                  { 'for': ['javascript', 'jsx']                      }
        Plug 'ternjs/tern_for_vim',                          { 'for': ['javascript', 'jsx'], 'do': 'npm install' }
        " markdown
        Plug 'plasticboy/vim-markdown',                      { 'for': ['markdown']                               } |
            \Plug 'nelstrom/vim-markdown-folding',           { 'for': ['markdown']                               }
        " clang
        Plug 'libclang-vim/libclang-vim',                    { 'for': ['c', 'cpp']                               } |
            \Plug 'kana/vim-textobj-user'                                                                          |
            \Plug 'libclang-vim/vim-textobj-clang',          { 'for': ['c', 'cpp']                               } |
            \Plug 'libclang-vim/vim-textobj-function-clang', { 'for': ['c', 'cpp']                               }
        " web
        Plug 'lepture/vim-jinja',                            { 'for': ['jinja', 'jinja.html', 'sls']             }
        Plug 'mattn/emmet-vim', {
            \'for': ['html', 'jinja.html', 'css', 'sass', 'scss', 'less']
        \}
    " }}}2

    " Beautify Vim. {{{2
        Plug 'chriskempson/base16-vim'
        Plug 'nathanaelkane/vim-indent-guides'
        Plug 'itchyny/lightline.vim'
        Plug 'luochen1990/rainbow'
        Plug 'AnsiEsc.vim'
        Plug 'ap/vim-css-color',          { 'for': ['css', 'scss', 'sass', 'less'] }
        Plug 'arakashic/chromatica.nvim', { 'for': ['c', 'cpp', 'objc', 'objcpp']  }
        "Plug 'qstrahl/vim-matchmaker'
    " }}}2

    " Direct text manipulation. {{{2
        Plug 'b4winckler/vim-angry'
        Plug 'junegunn/vim-easy-align'
        Plug 'tommcdo/vim-exchange'
        Plug 'cohama/lexima.vim'
        "Plug 'Raimondi/delimitMate'
        Plug 'scrooloose/nerdcommenter'
        Plug 'wellle/targets.vim'
        Plug 'tpope/vim-surround'
        Plug 'kana/vim-textobj-user'                    |
            \Plug 'kana/vim-textobj-indent'             |
            \Plug 'kana/vim-textobj-line'               |
            \Plug 'kana/vim-textobj-syntax'             |
            \Plug 'kana/vim-textobj-lastpat'            |
            \Plug 'kana/vim-textobj-fold'               |
            \Plug 'kana/vim-textobj-function'           |
            \Plug 'thinca/vim-textobj-between'          |
            \Plug 'glts/vim-textobj-comment'            |
            \Plug 'gilligan/textobj-gitgutter'          |
            \Plug 'saaguero/vim-textobj-pastedtext'     |
            \Plug 'paulhybryant/vim-textobj-path'       |
            \Plug 'beloglazov/vim-textobj-quotes'       |
            \Plug 'saihoooooooo/vim-textobj-space'      |
            \Plug 'jceb/vim-textobj-uri'                |
            \Plug 'Julian/vim-textobj-variable-segment'
    " }}}2

    " Silent enhancements. {{{2
        Plug 'editorconfig/editorconfig-vim'
        Plug 'kana/vim-niceblock'
        Plug 'tpope/vim-repeat'
        Plug 'sickill/vim-pasta'
        Plug 'unblevable/quick-scope', PIf(!has('nvim'))
    " }}}2

    call plug#end()
" Plugins }}}1


" FileType Settings {{{1
    augroup AllFiles
        au!
        au BufReadPost *
            \ if ! exists("g:leave_my_cursor_position_alone")      |
            \   let g:cursor_line = line("'\"")                    |
            \   if g:cursor_line > 0 && g:cursor_line <= line("$") |
            \     exe "normal g'\""                                |
            \   endif                                              |
            \ endif

        au    InsertEnter *
        \ setl relativenumber
        au    InsertLeave
        \,WinLeave
        \,BufLeave
        \,BufWinLeave
        \,TabLeave *
        \ setl norelativenumber
    augroup END
" Filetype Settings }}}1


" Initialize Vim {{{1
    if has('nvim')
        let $NVIM_TUI_ENABLE_TRUE_COLOR="1"
    endif

    if has('termguicolors')
        set termguicolors
    endif

    " do CursorLine stuff before `:colorsc` or `:set background`
    function! <SID>SetCursorLine()
        hi clear CursorLine
        hi CursorLineNR term=bold cterm=bold ctermfg=white gui=bold guifg=white
    endfunction
    call <SID>SetCursorLine()
    augroup CursorLine
        au!
        au! ColorScheme * :call <SID>SetCursorLine()
    augroup END

    try
        let base16colorspace    = 256
        let g:base16_shell_path = $BASE16_SHELL.'/scripts'
        set background=dark
        if filereadable(expand("~/.vimrc_background"))
            source ~/.vimrc_background
        endif
    catch
        try
            colorscheme jellybeans
        catch /^Vim(colorscheme):E185/
            colorscheme desert
        endtry
    endtry
" Initialize Vim }}}1


" {{{1 META: post
    " YO: yo
" }}}1 META: post
