" {{{1 vim: filetype=vim:
" AUTHOR: Zach Fogg <me@zfo.gg>
" DEPENDS:
"   VIM:      >= 7.4
"   VIMPAGER: >= 2.06
"   NEOVIM:   >= 0.1.5
" }}}1 `modeline`


" {{{1 Basic Settings
    set number           " display line numbers
    set numberwidth=1    " numberglyphs use only one column
    set title            " show file title in console title bar
    set wildmenu         " menu completion in command mode on <Tab>
    set showtabline=1    " show buffer tabs when more than one
    set pastetoggle=<F1> " for 'Insert' mode pasting with <S-Insert>
    set history=8192     " persist mode-cmdline history
    set wildmode=full    " <Tab> cycles between all matching choices.

    if !has('nvim')
        set nocompatible                  " vim > vi
        set t_Co=256                      " 256bit colors
        set noerrorbells visualbell t_vb= " no system bell, no screen blink on error
    endif

    " {{{2 undo / redo, swap, backup
        let s:vim_home = fnamemodify($MYVIMRC, ':p:h')
        let g:vim_home = s:vim_home
        let s:vim_dirs = {}
        for [s:dir_name, s:dir_path] in items({
            \ 'undo'   : '.undo',
            \ 'swap'   : '.swap',
            \ 'backup' : '.backup',
        \ })
            let s:dir = s:vim_home . '/' . s:dir_path
            if !isdirectory(s:dir) | call mkdir(s:dir) | endif
            let s:vim_dirs[s:dir_name] = s:dir[1:]
        endfor
        function! MyTmpdirs(...)
            if exists('a:1') | let l:pree  = a:1 | else | let l:pree  = '' | endif
            if exists('a:2') | let l:post  = a:2 | else | let l:post  = '' | endif
            let l:predirs = []
            if a:0 > 2
                let l:predirs = map(a:000[2:], 'l:pree . v:val . l:post')
                let l:predirs+= ['']
            endif
            let l:tmpdir = system('echo -n "${TMPDIR%/}"')
            return join(l:predirs, ',')
                \ . ''     . l:tmpdir      . l:post . ','
                \ . l:pree . 'private/tmp' . l:post . ','
                \ . l:pree . 'var/tmp'     . l:post . ','
                \ . l:pree . 'tmp'         . l:post
        endfunction

        " wildignore
        let &wildignore = MyTmpdirs('*/', '/*')
        set wildignore^=*/.git/*,*/.hg/*,*/.svn/*
        set wildignore^=*/node_modules/*,*/bower_components/*
        set wildignore^=*.o,*.obj,*.so,*.exe,*.dmg
        set wildignore^=*.swp,*.pyc,*.class
        set wildignore^=*.tar,*.bz,*.gz,*.xz,*.zip
        set wildignore^=*~

        " {un,re}do history
        let &undodir = MyTmpdirs('/', '', s:vim_dirs['undo'])
        set undofile

        " swapfiles
        let &directory = MyTmpdirs('/', '//', s:vim_dirs['swap'])

        " backups
        let &backupdir  = MyTmpdirs('/', '', s:vim_dirs['backup'])
        let &backupskip = MyTmpdirs('/', '/*',
            \ s:vim_dirs['undo'],
            \ s:vim_dirs['swap'],
            \ s:vim_dirs['backup'],
        \ )
    " }}}2 undo / redo, swap, backup

    " {{{2 Moving around and editing
        set nostartofline           " Avoid moving cursor to BOL when jumping around.
        set virtualedit=all         " Let cursor move past $ in command mode.
        set backspace=2             " Allow backspacing over autoindent, EOL, and BOL.
        set autoindent              " Always set autoindenting on.
        set lazyredraw              " For better macro performance.
    " }}}2 Moving around and editing

    " {{{2 Tiny aesthetic tweaks
        set cursorline              " A horizontal line for the cursor location.
        set ruler                   " Show the cursor position all the time.
        set scrolloff=3             " Keep n context lines above and below the cursor.
        set showmatch               " Briefly jump to a paren once it's balanced.
        set list                    " Visually display tabs and trailing whitespace.
        set listchars=trail:·,tab:·\ ,eol:¬,extends:>,precedes:<
    " }}}2 Tiny aesthetic tweaks

    " Whitespace {{{2
        set shiftwidth=4            " An indent level is n spaces.
        set expandtab               " Use spaces, not tabs, for autoindent/tab key.
        set tabstop=4               " <Tab> inserts n spaces.
        set softtabstop=4           " <BS> over an autoindent deletes both spaces.
        set shiftround              " Rounds indent to a multiple of shiftwidth.
        set linebreak               " Don't wrap textin the middle of a word.
        set nowrap                  " Don't wrap text.
        set textwidth=0             " Don't break lines.
        set wrapmargin=0            " Seriously, don't break lines.
    " }}}2

    " Folding. {{{2
        set foldenable
        set foldmethod=syntax
        set foldopen=mark,percent,quickfix,tag,undo
    " }}}2

    " Reading and writing. {{{2
        set noautowrite             " Never write a file unless I request it.
        set noautowriteall          " NEVER.
        set noautoread              " Don't automatically re-read changed files.
        set modeline                " Allow vim options to be embedded in files;
        set modelines=3             " they must be within the first or last 5 lines.
        set ffs=unix,dos,mac        " Try recognizing dos, unix, and mac line endings.
    " }}}2

    " Messages, info, and statuses. {{{2
        set ls=2                    " allways show status line
        set confirm                 " Y-N-C prompt if closing with unsaved changes.
        set showcmd                 " Show incomplete normal mode commands as I type.
        set report=0                " : commands always print changed line count.
        set shortmess+=a            " Use [+]/[RO]/[w] for modified/readonly/written.
        set ruler                   " Show some info, even without statuslines.
        set laststatus=2            " Always show statusline, even if only 1 window.
        set statusline=%<%f\ %h%m%r%{fugitive#statusline()}%=%-14.(%l,%c%V%)\ %P
    " }}}2

    " Searching and Patterns {{{2
        set ignorecase              " Default to using case insensitive searches.
        set smartcase               " unless uppercase letters are used in the regex.
        set smarttab                " Handle tabs more intelligently.
        set hlsearch                " Highlight searches by default.
        set incsearch               " Incrementally search while typing a /regex.
    " }}}2

    " The 'Session' plugin does this on save.
    set sessionoptions-=options

    " Per-project .vimrc.
    set exrc
    set secure

    " Faster CursorHold aucmd
    set updatetime=250 " milliseconds

    " http://stackoverflow.com/a/15471820
    if $TERM =~ '^\(screen\|xterm\)' && exists('$TMUX')
        set mouse+=a
    endif
" }}}1 Basic Settings


" Key Mappings {{{1
    let mapleader=","

    noremap : <Nop>
    noremap ; :
    " and if you ever wanna map to ;
    "noremap ;; ;

    " write
    nnoremap <Leader>w :w<CR>
    nmap     <Leader>W :silent! w<CR>
    cnoremap w! w !sudo tee % >/dev/null

    " quit
    nnoremap <Leader>q :q<CR>

    " vimrc
    nnoremap <Leader>v :tabnew $MYVIMRC<CR>
    nnoremap <Leader>V :source $MYVIMRC
                \ <Bar> filetype detect
                \ <Bar> echo 'vimrc reloaded'
                \ <Bar> <CR>

    " Disabled default commands. {{{2
        nnoremap  Q  <nop>
        map     <up> <nop>
        map   <down> <nop>
        map   <left> <nop>
        map  <right> <nop>
        imap    <up> <nop>
        imap  <down> <nop>
        imap  <left> <nop>
        imap <right> <nop>
    " }}}2

    " Yanking and pasting. {{{2
        " Copy to system clipboard.
        noremap <Leader>y "+y
        " Paste from system clipboard.
        noremap <Leader>p "+p
        " Easily yank from cursor to EOL.
        nnoremap Y y$
        " Retain " register after pasting.
        xnoremap <expr> p v:register=='"'?'pgvy':'p'
    " }}}2

    " Cursor motion. {{{2
        if empty($TMUX)
            nnoremap <C-H> <C-W>h
            nnoremap <C-J> <C-W>j
            nnoremap <C-K> <C-W>k
            nnoremap <C-L> <C-W>l
        else
            let g:tmux_navigator_no_mappings = 1
            nnoremap <silent> <C-h> :TmuxNavigateLeft<CR>
            nnoremap <silent> <C-j> :TmuxNavigateDown<CR>
            nnoremap <silent> <C-k> :TmuxNavigateUp<CR>
            nnoremap <silent> <C-l> :TmuxNavigateRight<CR>
            nnoremap <silent> <C-\> :TmuxNavigatePrevious<CR>
        end
        if has("nvim")
            tnoremap <silent> jj <C-\><C-n>{}k$
            tmap     <silent> <C-h> jj<C-h>
            tmap     <silent> <C-j> jj<C-j>
            tmap     <silent> <C-k> jj<C-k>
            tmap     <silent> <C-l> jj<C-l>
        end

        " j and k just work on long wrapped lines.
        nnoremap j gj
        nnoremap k gk

        " Scroll through items in the locations list.
        nmap <Leader>< <Plug>LocationPrevious
        nmap <Leader>> <Plug>LocationNext

        " A 'scrolling' effect.
        " FIXME: doesn't really work with in my iTerm+tmux setup.
        " nnoremap <a-j> <c-e>j
        " nnoremap <a-k> <c-y>k
        " nnoremap <a-l> zll
        " nnoremap <a-h> zhh

        " It should be very easy to leave `Insert-mode`.
        inoremap jj <Esc>
        inoremap kk <Esc>:w<CR>

        " Leaving `Insert-mode` is too much sometimes.
        inoremap HH <C-o>^
        inoremap LL <C-o>$

        " Jump to matching pairs easily with tab.
        vnoremap <Tab> %
    " }}}2

    " Folds. {{{2
        nnoremap <Space> za
        vnoremap <Space> za
    " }}}2

    " Tabs and splits. {{{2
        nnoremap <Leader>t :tabnew<CR>
        nnoremap <Leader>x :tabclose<CR>
        nnoremap <Leader>j :tabprevious<CR>
        nnoremap <Leader>k :tabnext<CR>

        " Resize splits.
        nnoremap <S-Up>    5<C-W>+
        nnoremap <S-Down>  5<C-W>-
        nnoremap <S-Right> 5<C-W>>
        nnoremap <S-Left>  5<C-W><
        nnoremap   <Up>     <C-W>+
        nnoremap   <Down>   <C-W>-
        nnoremap   <Right>  <C-W>>
        nnoremap   <Left>   <C-W><
    " }}}2

    " :make. {{{2
        "nnoremap <Leader>M  :silent! make<CR>:redraw!<CR>
        "nnoremap <Leader>Mc :silent! make clean<CR>:redraw!<CR>
        "nnoremap <Leader>Mm :silent! make clean all<CR>:redraw!<CR>
        "nnoremap <Leader>Mt :cclose \| silent! make test           \| copen<CR>:AnsiEsc<CR>G:redraw!<CR>
        "nnoremap <Leader>MT :cclose \| silent! make clean all test \| copen<CR>:AnsiEsc<CR>G:redraw!<CR>
    " }}}

    " Et cetera. {{{2
        " Previous matching command or search.
        cnoremap kk <Up>

        " Enter Replace mode from Visual mode.
        vnoremap R r<Space>R

        " Don't let `single-repeat` disturb the cursor's location.
        nnoremap . .`[

        " One less keypress to do use `Command-mode` from `Insert-mode`.
        imap <C-W> <C-O><C-W>

        " Delete trailing whitespace.
        nnoremap <Leader>S :%s/\s\+$//<cr>:let @/=''<CR><c-o>

        " Fixes for display glitches.
        nnoremap <silent> <Leader><Space> :nohlsearch<C-R>=has('diff')?'<Bar>diffupdate':''<CR><CR>,<Space>
        nnoremap <Leader>rd :redraw!<CR>

        " Set the background to transparent.
        "nnoremap <Leader>bg :hi Normal ctermbg=NONE<CR>

        " Change to the directory of the current buffer's file.
        nnoremap <Leader>lcd :lcd %:p:h<CR>
        nnoremap <Leader>cd  :cd  %:p:h<CR>

        " omnicomplete
        "imap </            <C-_>
        "nnoremap <Leader>/ <C-_>
    " }}}2
" Key Mappings }}}1


" Plugin Settings {{{1
    " NERDTree {{{2
        let NERDTreeWinPos="right"
        let NERDTreeMinimalUI=1
        let NERDTreeIgnore = [
            \ ''  . '\~'           . '$' . '[[file]]' ,
            \ ''  . '\~'           . '$' . '[[dir]]'  ,
            \ '^' . '\.git'        . '$' . '[[dir]]'  ,
            \ '^' . 'node_modules' . '$' . '[[dir]]'  ,
            \ ''  . '\.class'      . '$' . '[[file]]' ,
            \ ''  . '\.pyc'        . '$' . '[[file]]' ,
            \ ''  . '\.o'          . '$' . '[[file]]' ,
        \ ]
        " key bindings
        nmap <Leader>n<Space> :NERDTreeToggle<CR>
    " }}}2

    " NERDCommenter {{{2
        let NERDMenuMode               = "1"
        let NERDSpaceDelims            = "0"
        let NERDRemoveExtraSpaces      = "1"
        let NERDCompactSexyComs        = "1"
        let NERDAlignDefault           = "both"
        let NERDTrimTrailingWhitespace = "1"
    " }}}2

    " Fugitive. {{{2
        " key bindings
        nmap <Leader>gc :Gcommit<CR>
        nmap <Leader>gd :Gdiff<CR>
        nmap <Leader>gl :Glog<CR>
        nmap <Leader>gs :Gstatus<CR>
        nmap <Leader>gR :Gread<CR>
        nmap <Leader>gW :Gwrite<CR>:e<CR>
        nmap <Leader>gp :Git push<CR>
        nmap <Leader>gb :Gblame<CR>
        nmap <Leader>gH :Gbrowse<CR>
    " }}}2

    " IndentGuides {{{2
        let g:indent_guides_start_level           = 2
        let g:indent_guides_guide_size            = 1
        let g:indent_guides_enable_on_vim_startup = 1
        let g:indent_guides_auto_colors           = 0
        augroup IndentGuides
            au!
            au VimEnter,Colorscheme * :hi IndentGuidesEven ctermbg=grey     guibg=#585858
            au VimEnter,Colorscheme * :hi IndentGuidesOdd  ctermbg=darkgrey guibg=#383838
        augroup END
    " }}}2

    " Rainbow Parentheses {{{2
        let g:rainbow_active = 1
        let g:rainbow_conf = {
            \ 'operators': '_,_',
            \ 'parentheses': [
                \ 'start=/(/  end=/)/  fold',
                \ 'start=/\[/ end=/\]/ fold',
                \ 'start=/{/  end=/}/  fold',
            \ ],
            \ 'guifgs': [
                \ 'royalblue3',
                \ 'darkorange3',
                \ 'seagreen3',
                \ 'firebrick',
            \ ],
            \ 'ctermfgs': [
                \ 'lightblue',
                \ 'lightyellow',
                \ 'lightcyan',
                \ 'lightmagenta',
            \ ],
            \ 'separately': {
                \ '*': {},
                \ 'css': 0,
                \ 'phony.example': {
                    \ 'operators'   : '',
                    \ 'parentheses' : [],
                    \ 'guifgs'      : [],
                    \ 'ctermfgs'    : [],
                \ },
                \ 'vim': {
                    \ 'parentheses': [
                        \ 'start=/(/  end=/)/',
                        \ 'start=/\[/ end=/\]/',
                        \ 'start=/{/  end=/}/  fold',
                        \ 'start=/(/  end=/)/       containedin=vimFuncBody',
                        \ 'start=/\[/ end=/\]/      containedin=vimFuncBody',
                        \ 'start=/{/  end=/}/  fold containedin=vimFuncBody',
                    \ ],
                \ },
                \ 'html': {
                    \ 'parentheses': [
                        \ 'start=/\v\<((area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)[ >])@!\z([-_:a-zA-Z0-9]+)(\s+[-_:a-zA-Z0-9]+(\=("[^"]*"|'."'".'[^'."'".']*'."'".'|[^ '."'".'"><=`]*))?)*\>/ end=#</\z1># fold'
                    \ ],
                \ },
            \ }
        \ }
        augroup Rainbow_Parentheses
            au!
            au FileType lisp,clojure,scheme,json RainbowParentheses
        augroup END
        " key bindings
        nnoremap <Leader>RP<space> :RainbowParenthesesToggleAll<CR>
    " }}}2

    " YouCompleteMe {{{2
        let g:ycm_autoclose_preview_window_after_completion = 1
        let g:ycm_autoclose_preview_window_after_insertion  = 1
        let g:ycm_register_as_syntastic_checker             = 0
        let g:ycm_complete_in_comments                      = 1
        let g:ycm_seed_identifiers_with_syntax              = 1
        let g:ycm_collect_identifiers_from_tags_files       = 0
        "let g:ycm_extra_conf_globlist                       = ['~/src/*']
        let g:ycm_semantic_triggers =  {
            \ 'c,objc'                    : ['->', '.'],
            \ 'cpp,objcpp'                : ['->', '.', '::'],
            \ 'haskell'                   : ['.'],
            \ 'java'                      : ['.'],
            \ 'javascript,javascript.jsx' : ['.'],
            \ 'ocaml'                     : ['.',  '#'],
            \ 'php'                       : ['-,', '::'],
            \ 'python'                    : ['.'],
            \ 'vim'                       : ['.'],
        \ }
        let g:ycm_filetype_blacklist = {
            \ 'tagbar'   : 1,
            \ 'qf'       : 1,
            \ 'notes'    : 1,
            \ 'markdown' : 1,
            \ 'unite'    : 1,
            \ 'text'     : 1,
            \ 'vimwiki'  : 1,
            \ 'pandoc'   : 1,
            \ 'infolog'  : 1,
            \ 'mail'     : 1
        \ }
        " key bindings
        let g:ycm_key_list_select_completion   = ['<C-n>', '<Down>']
        let g:ycm_key_list_previous_completion = ['<C-p>', '<Up>']
        let g:SuperTabDefaultCompletionType    = '<C-n>'
    " }}}2

    " Ag {{{2
        if executable('ag')
            let g:ag_prg    = 'ag --vimgrep --nogroup --hidden -p '.$HOME.'/.agignore $*'
            let &grepprg    = g:ag_prg
            let &grepformat = '%f:%l:%c:%m'
        else
            let &grepprg = 'grep --exclude-dir .git -nrI $* . /dev/null'
        endif
    " Ag }}}2

    " C trlP {{{2
        let g:ctrlp_map               = '<C-p>'
        let g:ctrlp_cmd               = 'CtrlP'
        let g:ctrlp_root_markers      = ['.git',  '.hg', '.svn']
        let g:ctrlp_working_path_mode = 'ra'
        let g:ctrlp_cache_dir         = $HOME.'/.cache/ctrlp'
        let g:ctrlp_extensions        = ['mixed', 'tag', 'line', 'dir', 'commandline']
        let g:ctrlp_custom_ignore = {
          \ 'dir':  '\v[\/]\.(git|hg|svn)$',
          \ 'file': '\v\.(exe|so|dll)$',
          \ 'link': 'SOME_BAD_SYMBOLIC_LINKS',
          \ }
        let g:ctrlp_user_command = {
            \ 'types': {
                \ 1: ['.git', 'cd %s && git ls-files -co --exclude-standard'],
            \ },
        \ }
        " key bindings
        "nmap <C-p> <Plug>CtrlP
        "nmap <C-f> <Plug>CtrlPLine
    " }}}2

    " {{{2 EasyMotion
        "let g:EasyMotion_leader_key = '<Leader>'
    " }}}2 EasyMotion

    " EasyAlign{{{2
        nmap ga <Plug>(EasyAlign)
        xmap ga <Plug>(EasyAlign)
    " }}}2

    " Lightline {{{2
        let g:lightline = {
            \ 'colorscheme': 'jellybeans',
            \ 'active': {
                \ 'left': [
                    \ ['mode',     'paste'],
                    \ ['fugitive', 'filename'],
                    \ ['ctrlpmark'],
                \ ] ,
                \ 'right': [
                    \ ['syntastic',  'lineinfo'],
                    \ ['percent'],
                    \ ['fileformat', 'fileencoding', 'filetype'],
                \ ]
            \ },
            \ 'component_function': {
                \ 'fugitive'     : 'MyFugitive',
                \ 'filename'     : 'MyFilename',
                \ 'fileformat'   : 'MyFileformat',
                \ 'filetype'     : 'MyFiletype',
                \ 'fileencoding' : 'MyFileencoding',
                \ 'mode'         : 'MyMode',
                \ 'ctrlpmark'    : 'CtrlPMark',
            \ },
            \ 'component_expand': {
                \ 'syntastic': 'SyntasticStatuslineFlag',
            \ },
            \ 'component_type': {
                \ 'syntastic': 'error',
            \ },
            \ 'component': {
                \ 'readonly': '%{&readonly?"":""}',
            \ },
            \ 'separator'    : { 'left': '', 'right': '' },
            \ 'subseparator' : { 'left': '', 'right': '' }
        \ }

        function! MyModified()
            return &ft =~ 'help' ? '' : &modified ? '+' : &modifiable ? '' : '-'
        endfunction

        function! MyReadonly()
            return &ft !~? 'help' && &readonly ? 'RO' : ''
        endfunction

        function! MyFilename()
            let dname = expand('%:h:t')
            let fname = expand('%:t')
            let name  = dname . '/' . fname
            return fname == 'ControlP' ? g:lightline.ctrlp_item :
                    \ fname =~ 'NERD_tree' ? '' :
                    \ &ft == 'unite' ? unite#get_status_string() :
                    \ &ft == 'vimshell' ? vimshell#get_status_string() :
                    \ ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
                    \ ('' != name ? name : '[No Name]') .
                    \ ('' != MyModified() ? ' ' . MyModified() : '')
        endfunction

        function! MyFugitive()
            try
                if expand('%:t') !~? 'NERD' && exists('*fugitive#head')
                    let mark = ''  " edit here for cool mark
                    let _ = fugitive#head()
                    return strlen(_) ? mark._ : ''
                endif
            catch
            endtry
            return ''
        endfunction

        function! MyFileformat()
            return winwidth(0) > 70 ? &fileformat : ''
        endfunction

        function! MyFiletype()
            return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
        endfunction

        function! MyFileencoding()
            return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
        endfunction

        function! MyMode()
            let fname = expand('%:t')
            return fname == 'ControlP' ? 'CtrlP' :
                \ fname =~ 'NERD_tree' ? 'NERDTree' :
                \ &ft == 'unite' ? 'Unite' :
                \ winwidth(0) > 60 ? lightline#mode() : ''
        endfunction

        function! CtrlPMark()
            if expand('%:t') =~ 'ControlP'
                call lightline#link('iR'[g:lightline.ctrlp_regex])
                return lightline#concatenate([
                    \ g:lightline.ctrlp_prev ,
                    \ g:lightline.ctrlp_item ,
                    \ g:lightline.ctrlp_next ,
                \ ], 0)
            else
                return ''
            endif
        endfunction

        let g:ctrlp_status_func = {
            \ 'main': 'CtrlPStatusFunc_1',
            \ 'prog': 'CtrlPStatusFunc_2',
        \ }
        function! CtrlPStatusFunc_1(focus, byfname, regex, prev, item, next, marked)
            let g:lightline.ctrlp_regex = a:regex
            let g:lightline.ctrlp_prev = a:prev
            let g:lightline.ctrlp_item = a:item
            let g:lightline.ctrlp_next = a:next
            return lightline#statusline(0)
        endfunction
        function! CtrlPStatusFunc_2(str)
            return lightline#statusline(0)
        endfunction
    " }}}2

    " Neomake {{{2
        hi link NeomakeErrorSign   NeomakeErrorSignDefault
        hi link NeomakeWarningSign NeomakeWarningSignDefault
        augroup Neomake
            autocmd!
            " autocmd ColorScheme *
                " \ hi NeomakeErrorSign ctermfg=red guifg=red |
                " \ hi NeomakeWarningSign ctermfg=yellow guifg=yellow
            " autocmd! BufWritePost * Neomake
        augroup END
    " }}}2

    " Chromatica {{{2
        "let g:chromatica#libclang_path='/usr/local/opt/llvm/lib'
    " }}}2

    " Session {{{2
        let g:session_default_name      = 'default'           " When you don't name your session.
        let g:session_command_aliases   = 1                   " Use commands prefixed with 'Session'.
        let g:session_autosave          = 'yes'               " Save on exit sans prompt.
        let g:session_autosave_periodic = 4                   " Save every 'n' minutes.
        let g:session_autoload          = 0                   " Don't ask to open default session.
        let g:session_verbose_messages  = 0                   " Disable noisy save messages.
        let g:session_persist_globals   = ['&sessionoptions'] " Persist `vim-session` plugin opts
        call add(g:session_persist_globals, 'g:session_autosave')
        call add(g:session_persist_globals, 'g:session_autosave_periodic')
        call add(g:session_persist_globals, 'g:session_autoload')
        call add(g:session_persist_globals, 'g:session_default_to_last')
        call add(g:session_persist_globals, 'g:session_persist_globals')
        nmap <Leader>So :OpenSession<CR>
        nmap <Leader>Ss :SaveSession<CR>
        nmap <Leader>Sq :SaveSession<CR>:CloseSession<CR>
        nmap <Leader>SQ <Leader>Sq:q<CR>
    " }}}2

    " gitgutter {{{2
        let g:gitgutter_map_keys        = 0
        let g:gitgutter_highlight_lines = 0
        let g:gitgutter_async           = 0
        let g:gitgutter_realtime        = 0
        let g:gitgutter_eager           = 1
        let g:gitgutter_diff_args       = '-w'
        let g:gitgutter_max_signs       = 500
        " key bindings
        nmap gg<Space>  <Plug>GitGutterToggle
        nmap ggl<Space> <Plug>GitGutterLineHighlightsToggle
        nmap -          <Plug>GitGutterPrevHunk
        nmap =          <Plug>GitGutterNextHunk
        nmap ggw        <Plug>GitGutterStageHunk
        nmap ggu        <Plug>GitGutterUndoHunk
        nmap ggd        <Plug>GitGutterPreviewHunk
    " }}}2

    " editorconfig-vim {{{2
        let g:EditorConfig_exec_path = $HOMEBREW_PREFIX . '/bin/editorconfig'
    " }}}2

    " localvimrc {{{2
        let g:localvimrc_ask     = 0
        let g:localvimrc_sandbox = 0
    " }}}2

    " go {{{2
        let g:go_auto_type_info      = 1
        let g:go_highlight_operators = 1
        let g:go_highlight_functions = 1
        let g:go_highlight_methods   = 1
        let g:go_highlight_structs   = 1
    " }}}2

    " quick-scope {{{2
        "let g:qs_enable = 0
        "nnoremap <C-_> :normal ,<CR>
        "vnoremap <C-_> :normal ,<CR>
        "function! Quick_scope_selective(movement)
            "let needs_disabling = 0
            "if !g:qs_enable
                "QuickScopeToggle
                "redraw
                "let needs_disabling = 1
            "endif
            "let letter = nr2char(getchar())
            "if needs_disabling
                "QuickScopeToggle
            "endif
            "return a:movement . letter
        "endfunction
        " key bindings
        "nnoremap <expr> <silent> f Quick_scope_selective('f')
        "nnoremap <expr> <silent> F Quick_scope_selective('F')
        "nnoremap <expr> <silent> t Quick_scope_selective('t')
        "nnoremap <expr> <silent> T Quick_scope_selective('T')
        "vnoremap <expr> <silent> f Quick_scope_selective('f')
        "vnoremap <expr> <silent> F Quick_scope_selective('F')
        "vnoremap <expr> <silent> t Quick_scope_selective('t')
        "vnoremap <expr> <silent> T Quick_scope_selective('T')
    " }}}2
" Plugin Settings }}}1


" Define Plugins {{{1
    call plug#begin('~/.vim/bundle')

    function! PCond(cond, ...)
        let opts = get(a:000, 0, {})
        return a:cond ? opts : extend(opts, { 'on': [], 'for': [] })
    endfunction

    " Integrate with other programs. {{{2
        Plug 'rking/ag.vim', PCond(executable('ag'))
        Plug 'tpope/vim-fugitive'
        Plug 'xolox/vim-misc' | Plug 'xolox/vim-shell' |
            \ Plug 'airblade/vim-gitgutter'
        Plug 'Shougo/vimproc.vim', { 'do': 'make' }
        Plug 'tmux-plugins/vim-tmux', { 'for': 'tmux' }
        Plug 'tmux-plugins/vim-tmux-focus-events'
        Plug 'christoomey/vim-tmux-navigator', PCond(!empty($TMUX))
    " }}}2

    " Add features and functionality. {{{2
        Plug 'ctrlpvim/ctrlp.vim' |
            \ Plug 'suy/vim-ctrlp-commandline', { 'on': ['CtrlPLine'] }
        Plug 'Lokaltog/vim-easymotion'
        Plug 'scrooloose/nerdtree', { 'on':  'NERDTreeToggle' }
        Plug 'xolox/vim-misc' |
            \ Plug 'xolox/vim-session'
        Plug 'neomake/neomake'
        Plug 'ervandew/supertab' |
            \ Plug 'Valloric/YouCompleteMe', {
                \ 'do': './install.py'
                    \ . ' --clang-completer'
                    \ . ' --racer-completer'
                    \ . ' --gocode-completer'
                    \ . ' --tern-completer'
            \ }
        Plug 'embear/vim-localvimrc'
        Plug 'editorconfig/editorconfig-vim'
        Plug 'mattn/emmet-vim', { 'for': ['html', 'jinja.html', 'css', 'scss', 'less'] }
    " }}}2

    " Plugin plugins. {{{2
        "Plug 'rizzatti/dash.vim'
    " }}}2

    " Language support. {{{2
        "let g:polyglot_disabled = ['javascript']
        Plug 'sheerun/vim-polyglot'
        Plug 'applescript.vim', PCond(has('mac'), { 'for': 'applescript' })
        Plug 'guns/vim-clojure-highlight', { 'for': 'clojure' }
        Plug 'mxw/vim-jsx', { 'for': ['javascript', 'javascript.jsx'] }
        Plug 'lepture/vim-jinja', { 'for': ['jinja', 'jinja.html', 'sls'] }
        Plug 'saltstack/salt-vim', { 'for': 'sls' }
        Plug 'ternjs/tern_for_vim', { 'for': ['javascript', 'javascript.jsx'], 'do': 'npm install' }
    " }}}2

    " Beautify Vim. {{{2
        Plug 'chriskempson/base16-vim'
        Plug 'nathanaelkane/vim-indent-guides'
        Plug 'itchyny/lightline.vim'
        Plug 'luochen1990/rainbow'
        Plug 'AnsiEsc.vim', PCond(!exists('g:vimpager'))
        Plug 'ap/vim-css-color', { 'for': ['css', 'scss', 'sass', 'less'] }
        Plug 'arakashic/chromatica.nvim', { 'for': ['c', 'cpp'], 'as': 'chromatica' }
    " }}}2

    " Direct text manipulation. {{{2
        Plug 'b4winckler/vim-angry'
        Plug 'junegunn/vim-easy-align'
        Plug 'tommcdo/vim-exchange'
        Plug 'cohama/lexima.vim'
        "Plug 'Raimondi/delimitMate'
        Plug 'scrooloose/nerdcommenter'
        Plug 'wellle/targets.vim'
        Plug 'tpope/vim-surround'
        Plug 'kana/vim-textobj-user' |
            \ Plug 'kana/vim-textobj-indent'
    " }}}2

    " Silent enhancements. {{{2
        Plug 'kana/vim-niceblock'
        Plug 'sickill/vim-pasta'
        Plug 'tpope/vim-repeat'
        "Plug 'unblevable/quick-scope', PCond(has('nvim'))
    " }}}2
" Plugins }}}1


" FileType Settings {{{1
    augroup AllFiles
        au!
        " Return cursor to last position.
        au BufReadPost *
            \ if ! exists("g:leave_my_cursor_position_alone")   |
            \   if line("'\"") > 0 && line ("'\"") <= line("$") |
            \     exe "normal g'\""                             |
            \   endif                                           |
            \ endif
        " git-inline-diff on read,write
        "au BufReadPost,BufWritePost * exe "normal " . mapleader . "d"
    augroup END

    augroup VimL
        au!
        au FileType vim setl ts=4 sts=4 sw=4
        au FileType vim setl fdm=marker
    augroup END

    augroup C_Cpp
        au!
        au FileType c,c++ syn region foldPreprocessorIf start="^\#if" end="^\#endif" transparent fold
        au FileType c,c++ setl sw=4 ts=4 sts=4
        au FileType c,c++ setl fdm=marker fmr={,}
        au BufWritePost *.c,*.cpp,*.h,*.hpp silent YcmDiags
    augroup END

    augroup JavaScript
        au!
        au FileType javascript,javascript.jsx set foldmethod=syntax
    augroup END

    augroup Java
        au!
        au FileType java setl sw=4 ts=4 sts=4 fdm=marker fmr={,} fdl=1
    augroup END

    augroup HTML
        au!
        au FileType html,xhtml,xml,css setl expandtab sw=4 ts=4 sts=4
        " Templating languages.
        au FileType mustache,handlebars,hbs setl expandtab sw=4 ts=4 sts=4
    augroup END

    augroup Python
        au!
        au FileType python setl expandtab sw=4 sts=4 cinwords=if,elif,else,for,while,try,except,finally,def,class,with
        "au FileType python set omnifunc=pythoncomplete#Complete
        au FileType python setl efm=%C\ %.%#,%A\ \ File\ \"%f\"\\,\ line\ %l%.%#,%Z%[%^\ ]%\\@=%m
    augroup END

    augroup Markdown
        au!
        au BufRead,BufNewFile *.md setl ft=markdown
    augroup END

    augroup JSON
        au!
        au BufRead,BufNewFile *.json set filetype=json
        au BufRead,BufNewFile .eslintrc,.babelrc set ft=json
    augroup END

    augroup YAML
        au!
        au BufRead,BufNewFile *.yml set sw=2
    augroup END

    augroup AppleScript
        au!
        au BufRead,BufNewFile *.AppleScript set ft=applescript
    augroup END
" Filetype Settings }}}1


" Initialize Vim {{{1
    call plug#end()

    if has('nvim')
        let $NVIM_TUI_ENABLE_TRUE_COLOR="1"
        set termguicolors
    endif

    try                                 " Fall back to preferred colorschemes.
        let base16colorspace=256        " Access colors present in 256 colorspace
        colorscheme base16-default-dark
    catch
        try
            set background=dark
            colorscheme jellybeans
        catch /^Vim\%((\a\+)\)\=:E185/
            colorscheme desert
        endtry
    endtry

    " White cursorline number
    function! <SID>SetCursorLine()
        hi clear CursorLine
        hi CursorLineNR cterm=bold ctermfg=white guifg=white
    endfunction
    call <SID>SetCursorLine()
    augroup _CursorLine
        au!
        au! ColorScheme * :call <SID>SetCursorLine()
    augroup END
" Initialize Vim }}}1

