" {{{1 ~/.vimpagerrc
"  vim: filetype=vim:
" AUTHOR: Zach Fogg <me@zfo.gg>
" DEPENDS:
"   VIM:      >= 7.4
"   VIMPAGER: >= 2.06
"   NEOVIM:   >= 0.1.5
" }}}1 zfogg/dotfiles ~/.vim/init.vim


" {{{1 META: pre
    scriptencoding utf-8
    " {{{2 config paths
            " s:mvvar =~# escape('s:\i+(_(l|f|r))?', '+()|?')
                " s:myvar_l  (l)ocal path basename
                " s:myvar_f  (f)ully resolved links (expanded vars)
                " s:myvar_r  (r)elative to $HOME (un-expanded vars)
        " dir/ ~/.dotfiles/ 's:dotfiles'
        let s:dotfiles_l = '.dotfiles'
        let s:dotfiles   = fnamemodify(exists('$DOTFILES') ? $DOTFILES : s:dotfiles_l, ':~')
        let s:dotfiles_f = expand(s:dotfiles)
        let s:dotfiles_r = fnamemodify(s:dotfiles, ':~')
        " dir/ ~/.vim/ 's:dotvim'
        let s:dotvim_l   = '.vim'
        let s:dotvim     = exists('$DOTVIM')               ? $DOTVIM   : s:dotfiles.'/'.s:dotvim_l
        let s:dotvim_f   = expand(s:dotvim)
        let s:dotvim_r   = fnamemodify(s:dotvim,   ':~')
        " file ~/.vim/init.vim 's:myvimrc'
        let s:myvimrc_l = 'init.vim'
        let s:myvimrc   = s:dotvim  .'/'.s:myvimrc_l
        let s:myvimrc_f = s:dotvim_f.'/'.s:myvimrc_l
        let s:myvimrc_r = s:dotvim_r.'/'.s:myvimrc_l
    " }}}2 config paths
" }}}1 META: pre


" {{{1 Basic Settings
    set number numberwidth=3    " hybrid line numbers - relative & static
    set title                   " file title in the $TERM titlebar
    set showtabline=1           " show buffer tabs when more than `n`
    set pastetoggle=<F1>        " for 'Insert' mode pasting with <S-Insert>
    set history=8192            " persist mode-cmdline history
    set noerrorbells visualbell " no system bell, no screen blink on error
    set wildmenu                " custom completion menu
    set wildmode=
        \longest:full,
        \list:full

    let g:netrw_dirhistmax=0 " http://www.vim.org/scripts/script.php?script_id=1075

    " {{{2 undo / redo, swap, backup
        let s:dotvim_dotdirs = {}
        for [s:dir_name, s:dir_path] in items({
            \ 'undo'   : '.undo',
            \ 'swap'   : '.swap',
            \ 'backup' : '.backup',
        \ })
            let s:dir = s:dotvim_f.'/'.s:dir_path
            if !isdirectory(s:dir) | call mkdir(s:dir) | endif
            let s:dotvim_dotdirs[s:dir_name] = s:dir[1:]
        endfor

        if !exists('g:mytmpdir')
            let g:mytmpdir = system('echo -n "${TMPDIR%/}"')
        endif

        function! MyTmpdirs(pree, post, ...)
            let l:pree = exists('a:pree') ? a:pree : ''
            let l:post = exists('a:post') ? a:post : ''
            let l:pre_dirs = a:0 > 0
                \ ? map(copy(a:000), 'l:pree . v:val . l:post')
                \ : []
            let l:std_dirs = [
                \          g:mytmpdir    . l:post,
                \ l:pree . 'private/tmp' . l:post,
                \ l:pree . 'var/tmp'     . l:post,
                \ l:pree . 'tmp'         . l:post,
            \ ]
            let l:out_dirty = join(l:pre_dirs + l:std_dirs, ',')
            return escape(l:out_dirty, '\')
        endfunction

        " wildignore
        set wildignore+=*.o,*.obj,*.so,,*.exe,*.dll,*.manifest,*.dmg
        set wildignore+=*.swp,*.pyc,*.class
        set wildignore+=*.tar,*.bz,*.gz,*.xz,*.zip
        set wildignore+=*~

        " {un,re}do history
        let &undodir = MyTmpdirs('/', '', s:dotvim_dotdirs['undo'])
        set undofile

        " swapfiles
        let &directory = MyTmpdirs('/', '//', s:dotvim_dotdirs['swap'])

        " backups
        let &backupdir  = MyTmpdirs('/', '', s:dotvim_dotdirs['backup'])
        let &backupskip = MyTmpdirs('/', '/*',
            \ s:dotvim_dotdirs['undo'],
            \ s:dotvim_dotdirs['swap'],
            \ s:dotvim_dotdirs['backup'],
        \ )
        set backupskip=&backupskip
    " }}}2 undo / redo, swap, backup

    " {{{2 Moving around and editing
        set nostartofline   " Avoid moving cursor to BOL when jumping around.
        set virtualedit=all " Let cursor move past $ in command mode.
        set backspace=2     " Allow backspacing over autoindent, EOL, and BOL.
        set autoindent      " Always set autoindenting on.
        set lazyredraw      " For better macro performance.
    " }}}2 Moving around and editing

    " {{{2 Tiny aesthetic tweaks
        set cursorline      " A horizontal line for the cursor location.
        set ruler           " Show the cursor position all the time.
        set scrolloff=3     " Keep n context lines above and below the cursor.
        set sidescrolloff=5 " FIXME
        set sidescroll=1    " FIXME
        set showmatch       " Briefly jump to a paren once it's balanced.
        set list            " Visually display tabs and trailing whitespace.
        set listchars=
            \eol:¬,
            \tab:→\ ,
            \trail:·,
            \extends:⟩,
            \precedes:⟨,
            \nbsp:␣
    " }}}2 Tiny aesthetic tweaks

    " Whitespace {{{2
        set expandtab       " Use spaces, not tabs, for autoindent/tab key.
        set copyindent
        set preserveindent
        set softtabstop=4   " <BS> over an autoindent deletes both spaces.
        set shiftwidth=4    " An indent level is n spaces.
        set tabstop=4       " <Tab> inserts n spaces.
        set shiftround      " Rounds indent to a multiple of shiftwidth.
        set nowrap          " Don't wrap text.
        set linebreak       " Don't wrap textin the middle of a word.
        set wrapmargin=0    " Seriously, don't break lines.
        set textwidth=0     " Don't break lines.
        set showbreak=↪\    " Visualize wrapped lines.
    " }}}2

    " Folding. {{{2
        set foldmethod=syntax
        set foldopen=mark,percent,quickfix,tag,undo
        set foldenable
    " }}}2

    " Reading and writing. {{{2
        set noautowrite      " Never write a file unless I request it.
        set noautowriteall   " NEVER.
        set noautoread       " Don't automatically re-read changed files.
        set modeline         " Allow vim options to be embedded in files;
        set modelines=3      " they must be within the first or last 5 lines.
        set ffs=unix,dos,mac " Try recognizing dos, unix, and mac line endings.
    " }}}2

    " Messages, info, and statuses. {{{2
        set shortmess=aOstTI " :help 'shortmess'
        set laststatus=2     " allways show status line
        set confirm          " Y-N-C prompt if closing with unsaved changes.
        set showcmd          " Show incomplete normal mode commands as I type.
        set report=0         " : commands always print changed line count.
        set ruler            " Show some info, even without statuslines.
        set laststatus=2     " Always show statusline, even if only 1 window.
        "set statusline=%<%f\ %h%m%r%{fugitive#statusline()}%=%-14.(%l,%c%V%)\ %P
    " }}}2

    " Searching and Patterns {{{2
        set ignorecase " Default to using case insensitive searches.
        set smartcase  " unless uppercase letters are used in the regex.
        set smarttab   " Handle tabs more intelligently.
        set hlsearch   " Highlight searches by default.
        set incsearch  " Incrementally search while typing a /regex.
    " }}}2

    " The 'Session' plugin does this on save.
    set sessionoptions-=blank
    set sessionoptions-=buffers

    " Per-project .vimrc.
    "   NOTE: don't ever set this, you moron
    "set exrc secure

    " Faster CursorHold aucmd
    set updatetime=180 " milliseconds

    set shell=$SHELL

    " 'text-obj' patterns for 'word' and file /path
        " NOTE: http://www.ascii-code.com/
            " '@'       == /[a-zA-Z]/ == filter(isalpha, $ascii_arr)
            " ,48-57,   == /[0-9]/    == filter(isdigit, $ascii_arr)
            " ,192-255, == /[À-ÿ]/    /* accented characters - extended ascii */
            " ,,,       == /,/
            " ,@-@,     == /@/
            " ,^,,      == /[^,]/
            " ,^<EOL>   == /\^/
        " NOTE: :h 'isfname' | :help 'iskeyword'
    set   isfname=@,48-57,_,#,~,$,-,/,.,+,,,%,=
    set iskeyword=@,48-57,_,192-255
" }}}1 Basic Settings


" Key Mappings {{{1
    let g:mapleader=','

    inoremap <C-c> <Esc>

    noremap : <Nop>
    noremap ; :
    " and if you ever wanna map to ;
    "noremap ;; ;

    " write
    nnoremap <Leader>w :w<CR>
    nnoremap <Leader>W :sil! w<CR>
    cnoremap w! w !sudo tee % >/dev/null

    " quit
    nnoremap <Leader>q :q<CR>

    " vimrc
    exe 'nn <silent> <Leader>v :'
        \.'cd '.s:dotvim_r             .' <Bar> '
        \.'$tabe! '                    .' <Bar> '
        \.'e '.s:myvimrc_l             .' <Bar> '
        \.'cd -'                       .' <Bar> '
        \.'exe "norm! zvzz"'           .' <Bar> '
        \.'<CR>'
    exe 'nn <silent> <Leader>V :'
        \.'cd '.s:dotvim_r             .' <Bar> '
        \.'so '.s:myvimrc_l            .' <Bar> '
        \.'cd -'                       .' <Bar> '
        \.'filet detect'               .' <Bar> '
        \.'exe "norm! zvzz"'           .' <Bar> '
        \.'<CR>'

    " Disabled default commands. {{{2
        nnoremap Q       <Nop>
        noremap  <Up>    <Nop>
        noremap  <Down>  <Nop>
        noremap  <Left>  <Nop>
        noremap  <Right> <Nop>
        inoremap <Up>    <Nop>
        inoremap <Down>  <Nop>
        inoremap <Left>  <Nop>
        inoremap <Right> <Nop>
    " }}}2

    " Yanking and pasting. {{{2
        " Copy to system clipboard.
        noremap <Leader>y "+y
        " Paste from system clipboard.
        noremap <Leader>p "+p
        " Easily yank from cursor to EOL.
        nnoremap Y y$
        " Retain " register after pasting.
        xnoremap <expr> p v:register=='"'?'pgvy':'p'
    " }}}2

    " Cursor motion. {{{2
        if empty($TMUX)
            nnoremap <C-H> <C-W>h
            nnoremap <C-J> <C-W>j
            nnoremap <C-K> <C-W>k
            nnoremap <C-L> <C-W>l
        else
            let g:tmux_navigator_no_mappings = 1
            nnoremap <silent> <C-h> :TmuxNavigateLeft<CR>
            nnoremap <silent> <C-j> :TmuxNavigateDown<CR>
            nnoremap <silent> <C-k> :TmuxNavigateUp<CR>
            nnoremap <silent> <C-l> :TmuxNavigateRight<CR>
            nnoremap <silent> <C-\> :TmuxNavigatePrevious<CR>
        end
        if has('nvim')
            let $NVIM_TUI_ENABLE_CURSOR_SHAPE = 1          " change cursor to bar in insert mode
            tnoremap <Esc> <C-\><C-n>
            tnoremap     <silent> jj <C-\><C-n>{}k$
            tnoremap     <silent> <C-j> jj<C-j>
            tnoremap     <silent> <C-k> jj<C-k>
            tnoremap     <silent> <C-l> jj<C-l>
        end

        " j and k just work on long wrapped lines.
        nnoremap j gj
        nnoremap k gk

        " Scroll through items in the locations list.
        nmap <Leader>< <Plug>LocationPrevious
        nmap <Leader>> <Plug>LocationNext

        " A 'scrolling' effect.
        " FIXME: doesn't really work with in my iTerm+tmux setup.
        " nnoremap <a-j> <c-e>j
        " nnoremap <a-k> <c-y>k
        " nnoremap <a-l> zll
        " nnoremap <a-h> zhh

        " think of your left pinky
        inoremap jj    <Esc>
        inoremap kk    <Esc>:w<CR>

        " Leaving `Insert-mode` is too much sometimes.
        inoremap HH <C-o>^
        inoremap LL <C-o>$

        " Jump to matching pairs easily with tab.
        vnoremap <Tab> %
    " }}}2

    " Folds. {{{2
        nnoremap <Space> za
        vnoremap <Space> za
    " }}}2

    " Tabs and splits. {{{2
        nnoremap <Leader><C-t> :tabnew<CR>
        nnoremap <Leader>x     :tabclose<CR>
        nnoremap <Leader>j     :tabprevious<CR>
        nnoremap <Leader>k     :tabnext<CR>
        " Resize splits.
        nnoremap <S-Up>    5<C-W>+
        nnoremap <S-Down>  5<C-W>-
        nnoremap <S-Right> 5<C-W>>
        nnoremap <S-Left>  5<C-W><
        nnoremap   <Up>     <C-W>+
        nnoremap   <Down>   <C-W>-
        nnoremap   <Right>  <C-W>>
        nnoremap   <Left>   <C-W><
    " }}}2

    " :make. {{{2
        "nnoremap <Leader>M  :silent! make<CR>:redraw!<CR>
        "nnoremap <Leader>Mc :silent! make clean<CR>:redraw!<CR>
        "nnoremap <Leader>Mm :silent! make clean all<CR>:redraw!<CR>
        "nnoremap <Leader>Mt :cclose \| silent! make test           \| copen<CR>:AnsiEsc<CR>G:redraw!<CR>
        "nnoremap <Leader>MT :cclose \| silent! make clean all test \| copen<CR>:AnsiEsc<CR>G:redraw!<CR>
    " }}}

    " Et cetera. {{{2
        " Previous matching command or search.
        cnoremap kk <Up>
        cnoremap HH <Home>
        cnoremap LL <Home>

        " Enter Replace mode from Visual mode.
        vnoremap R r<Space>R

        " Don't let `single-repeat` disturb the cursor's location.
        nnoremap . .`[

        " Delete trailing whitespace.
        nnoremap <Leader>S :%s/\s\+$//<CR>:let @/=''<CR><c-o>

        " Fixes for display glitches.
        nnoremap <silent> <Leader><Space> :nohlsearch<C-R>=has('diff')?'<Bar>diffupdate':''<CR><CR>,<Space>
        nnoremap <Leader>rd :redraw!<CR>

        " Set the background to transparent.
        "nnoremap <Leader>bg :hi Normal ctermbg=NONE<CR>

        " Change to the directory of the current buffer's file.
        nnoremap <Leader>lcd :lcd %:p:h<BAR>pwd<CR>
        nnoremap <Leader>cd  :cd  %:p:h<BAR>pwd<CR>

        " omnicomplete
        "imap </            <C-_>
        "nnoremap <Leader>/ <C-_>
    " }}}2
" Key Mappings }}}1


" Plugin Settings {{{1
    " NERDTree {{{2
        let g:NERDTreeWinPos                    = 'left'
        let g:NERDTreeAutoCenter                = 1
        let g:NERDTreeCaseSensitiveSort         = 0
        let g:NERDTreeHighlightCursorline       = 1
        let g:NERDTreeBookmarksFile             = s:dotvim_f.'.cache/NERDTree.bookmarks'
        let g:NERDTreeMouseMode                 = 2
        let g:NERDTreeShowHidden                = 1
        let g:NERDTreeMinimalUI                 = 1
        let g:NERDTreeHijackNetrw               = 1
        let g:NERDTreeRespectWildIgnore         = 1
        let g:NERDTreeCascadeOpenSingleChildDir = 2
        let g:NERDTreeAutoDeleteBuffer          = 1
        "let g:NERDTreeChDirMode                 = 2
        let g:NERDTreeWinSize                   = 24

        let g:NERDTreeCreatePrefix = 'silent keepa keepj keepp keepm'

        let g:NERDTreeIgnore    = [ '\~$' ,
            \ '' . '.git'             . '$' . '[[dir]]'  ,
            \ '' . '.hg'              . '$' . '[[dir]]'  ,
            \ '' . '.svn'             . '$' . '[[dir]]'  ,
            \ '' . 'node_modules'     . '$' . '[[dir]]'  ,
            \ '' . 'bower_components' . '$' . '[[dir]]'  ,
            \ ''  . '.o'              . '$' . '[[file]]' ,
            \ ''  . '.obj'            . '$' . '[[file]]' ,
            \ ''  . '.so'             . '$' . '[[file]]' ,
            \ ''  . '.exe'            . '$' . '[[file]]' ,
            \ ''  . '.dmg'            . '$' . '[[file]]' ,
            \ ''  . '.swap'           . '$' . '[[file]]' ,
            \ ''  . '.class'          . '$' . '[[file]]' ,
            \ ''  . '.pyc'            . '$' . '[[file]]' ,
            \ ''  . '.tar'            . '$' . '[[file]]' ,
            \ ''  . '.bz'             . '$' . '[[file]]' ,
            \ ''  . '.gz'             . '$' . '[[file]]' ,
            \ ''  . '.xz'             . '$' . '[[file]]' ,
            \ ''  . '.zip'            . '$' . '[[file]]' ,
            \ ''  . '.DS_Store'       . '$' . '[[file]]' ,
            \ ''  . '%'               . ''  . '[[file]]' ,
        \ ]

        " command - toggle
        func! <SID>MyNERDTreeToggle()
            if exists('t:NERDTreeBufName')
                if exists('g:zNTOn') || &buftype !=# ''
                    unlet! g:zNTOn
                    NERDTreeClose
                    return
                else
                    NERDTree
                endif
            else
                NERDTree %:p:h
            endif
            let g:zNTOn = 1
            wincmd p
        endfunc
        nnoremap <silent> <Leader>n<Space> :call <SID>MyNERDTreeToggle()<CR>

        " autocommand - auto-cwd (BufEnter *)
        func! <SID>MyNERDTreeAutoCWD()
            if exists('b:noNERDTreeAutoCWD')
                return
            elseif exists('g:zNTOn')
                "cd %:p:h
                NERDTreeMirror
                wincmd p
            endif
        endfunc

        aug <SID>MyNERDTree
            au!
            "au BufEnter      * silent! call <SID>MyNERDTreeAutoCWD()
            "au TabNew * call <SID>MyNERDTreeToggle()
        aug END
    " }}}2

    " NERDCommenter {{{2
        let g:NERDMenuMode               = 1
        let g:NERDSpaceDelims            = 0
        let g:NERDRemoveExtraSpaces      = 1
        let g:NERDCompactSexyComs        = 1
        let g:NERDAlignDefault           = 'both'
        let g:NERDTrimTrailingWhitespace = 1
        " `&filetype` settings
        let g:NERDAltDelims_haskell    = 1
    " }}}2

    " Fugitive. {{{2
        " key bindings
        nmap <Leader>gc :Gcommit<CR>
        nmap <Leader>gd :Gdiff<CR>
        nmap <Leader>gl :Glog<CR>
        nmap <Leader>gs :Gstatus<CR>
        nmap <Leader>gR :Gread<CR>
        nmap <Leader>gW :Gwrite<CR>:e<CR>
        nmap <Leader>gp :Git push<CR>
        nmap <Leader>gb :Gblame<CR>
        nmap <Leader>gH :Gbrowse<CR>
    " }}}2

    " IndentGuides {{{2
        let g:indent_guides_start_level           = 2
        let g:indent_guides_guide_size            = 1
        let g:indent_guides_enable_on_vim_startup = 1
        let g:indent_guides_auto_colors           = 0
        function! <SID>SetIndentGuideColors()
            hi clear IndentGuidesOdd
            hi clear IndentGuidesEven
            hi IndentGuidesOdd  ctermbg=19 guibg=#383838
            hi IndentGuidesEven ctermbg=08 guibg=#585858
        endfunction
        augroup IndentGuides
            au!
            au! VimEnter,Colorscheme * :call <SID>SetIndentGuideColors()
        augroup END
    " }}}2

    " Rainbow Parentheses {{{2
        "let g:rainbow_active = 1
        let g:rainbow_conf = {
            \ 'operators': '_,_',
            \ 'parentheses': [
                \ 'start=/(/  end=/)/  fold',
                \ 'start=/\[/ end=/\]/ fold',
                \ 'start=/{/  end=/}/  fold',
            \ ],
            \ 'guifgs': [
                \ 'royalblue3',
                \ 'darkorange3',
                \ 'seagreen3',
                \ 'firebrick',
            \ ],
            \ 'ctermfgs': [
                \ 'lightblue',
                \ 'lightyellow',
                \ 'lightcyan',
                \ 'lightmagenta',
            \ ],
            \ 'separately': {
                \ '*': {},
                \ 'css': 0,
                \ 'phony.example': {
                    \ 'operators'   : '',
                    \ 'parentheses' : [],
                    \ 'guifgs'      : [],
                    \ 'ctermfgs'    : [],
                \ },
                \ 'vim': {
                    \ 'parentheses': [
                        \ 'start=/(/  end=/)/',
                        \ 'start=/\[/ end=/\]/',
                        \ 'start=/{/  end=/}/  fold',
                        \ 'start=/(/  end=/)/       containedin=vimFuncBody',
                        \ 'start=/\[/ end=/\]/      containedin=vimFuncBody',
                        \ 'start=/{/  end=/}/  fold containedin=vimFuncBody',
                    \ ],
                \ },
                \ 'html': {
                    \ 'parentheses': [
                        \ 'start=/\v\<((area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)[ >])@!\z([-_:a-zA-Z0-9]+)(\s+[-_:a-zA-Z0-9]+(\=("[^"]*"|'."'".'[^'."'".']*'."'".'|[^ '."'".'"><=`]*))?)*\>/ end=#</\z1># fold'
                    \ ],
                \ },
            \ }
        \ }
        " key bindings
        "nnoremap <Leader>rp<Space> :RainbowTogglp<CR>
    " }}}2

    " SuperTab {{{2
        let g:SuperTabDefaultCompletionType = '<c-n>'
    " }}}2

    " Ag {{{2
        if executable('ag')
            let g:ag_prg    = 'ag --vimgrep --nogroup --hidden -p '.$HOME.'/.agignore $*'
            let &grepprg    = g:ag_prg
            let &grepformat = '%f:%l:%c:%m'
        else
            let &grepprg = 'grep --color=never -e --exclude-dir .git -nrI $* . /dev/null'
        endif
    " Ag }}}2

    " {{{2 EasyMotion
        "let g:EasyMotion_leader_key = '<Leader>'
        "nnoremap <Leader><Leader> <Plug>(easymotion-prefix)
    " }}}2 EasyMotion

    " EasyAlign{{{2
        nmap ga <Plug>(EasyAlign)
        xmap ga <Plug>(EasyAlign)
        let g:easy_align_ignore_groups          = ['Comment', 'String']  "[]
        let g:easy_align_interactive_modes      = ['l', 'r', 'c']        "['l', 'r', 'c']
        let g:easy_align_bang_interactive_modes = ['r', 'l', 'c']        "['r', 'l', 'c']
    " }}}2

    " Lightline {{{2
        let g:lightline = {
            \ 'colorscheme': 'jellybeans'
            \,'separator'    : { 'left': '', 'right': '' }
            \,'subseparator' : { 'left': '', 'right': '' }
            \,'active': {
                \ 'left': [
                    \ ['mode', 'paste']
                    \,['fugitive', 'filename']
                \ ],
                \ 'right': [
                    \ ['lineinfo', 'neomake']
                    \,['percent']
                    \,['fileformat', 'fileencoding', 'filetype']
                \ ],
            \ },
            \ 'component_function': {
                \ 'readonly'     : 'LightLineReadonly'
                \,'modified'     : 'LightLineModified'
                \,'fugitive'     : 'LightLineFugitive'
                \,'filename'     : 'LightLineFilename'
                \,'fileformat'   : 'LightLineFileformat'
                \,'filetype'     : 'LightLineFiletype'
                \,'fileencoding' : 'LightLineFileencoding'
                \,'mode'         : 'LightLineMode'
            \ },
            \ 'component_expand': {
                \ 'neomake' : 'LightLineNeomake'
            \ },
            \ 'component_type': {
                \ 'neomake' : 'error'
            \ },
        \ }

        function! LightLineReadonly()
            if &ft ==? 'help' | return ''
            elseif &readonly  | return '🔒'
            else              | return '' | endif
        endfunction

        function! LightLineModified()
            if &ft ==? 'help'   | return ''
            elseif &modified    | return '+'
            elseif &modifiable  | return '-'
            else                | return '' | endif
        endfunction

        function! LightLineFugitive()
            try
                if expand('%:t') !~? 'NERD' && &ft !~? 'vimfiler' && exists('*fugitive#head')
                let l:branch = fugitive#head()
                return l:branch !=# '' ? ' ' . l:branch : ''
                endif
            catch
            endtry
            return ''
        endfunction

        function! LightLineFilename()
            let l:fname = expand('%:t')
            return ('' !=? LightLineReadonly() ?       LightLineReadonly() . ' ' : '') .
                \  ('' !=# l:fname ? expand('%:h:t').'/'.l:fname : '[No Name]') .
                \  ('' !=? LightLineModified() ? ' ' . LightLineModified()       : '')
        endfunction

        function! LightLineFileformat()
            return winwidth(0) > 70 ? &fileformat : ''
        endfunction

        function! LightLineFiletype()
            return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
        endfunction

        function! LightLineFileencoding()
            return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
        endfunction

        function! LightLineMode()
            let l:fname = expand('%:t')
            return l:fname =~? 'NERD_tree' ? 'NERDTree' :
                \ winwidth(0) > 60 ? lightline#mode() : ''
        endfunction

        function! LightLineNeomake()
            return '%{neomake#statusline#LoclistStatus()}'
        endfunction


        function! OnNeomakeCountsChanged() abort
            call lightline#update()
        endfunction

        aug MyLightLine
            au!
            au User NeomakeCountsChanged,NeomakeMakerFinished call OnNeomakeCountsChanged()
        aug END

    " }}}2

    " Chromatica {{{2
        let g:chromatica#libclang_path=$BREW.'/opt/llvm/lib'
    " }}}2

    " Session {{{2
        let g:session_default_name      = 'default'           " When you don't name your session.
        let g:session_command_aliases   = 1                   " Use commands prefixed with 'Session'.
        let g:session_autosave          = 'yes'               " Save on exit sans prompt.
        let g:session_autosave_periodic = 2                   " Save every 'n' minutes.
        let g:session_autoload          = 0                   " Don't ask to open default session.
        let g:session_verbose_messages  = 0                   " Disable noisy save messages.
        let g:session_persist_globals   = ['&sessionoptions'] " Persist `vim-session` plugin opts
        call add(g:session_persist_globals, 'g:session_autosave')
        call add(g:session_persist_globals, 'g:session_autosave_periodic')
        call add(g:session_persist_globals, 'g:session_autoload')
        call add(g:session_persist_globals, 'g:session_default_to_last')
        call add(g:session_persist_globals, 'g:session_persist_globals')
        nnoremap <Leader>So :OpenSession<CR>
        nnoremap <Leader>Ss :SaveSession<CR>
        nnoremap <Leader>Sq :SaveSession<CR>:CloseSession<CR>
        nnoremap <Leader>SQ <Leader>Sq:q<CR>
    " }}}2

    " gitgutter {{{2
        let g:gitgutter_enabled         = 1
        let g:gitgutter_map_keys        = 1
        let g:gitgutter_highlight_lines = 0
        let g:gitgutter_async           = 1
        let g:gitgutter_realtime        = 1
        let g:gitgutter_eager           = 1
        let g:gitgutter_diff_args       = '-w'
        let g:gitgutter_max_signs       = 1024
        "let g:gitgutter_grep_command    = &grepprg
        " key bindings
        nnoremap <Leader>gg<Space>  :GitGutterToggle<CR>
        nnoremap <Leader>ggl<Space> :GitGutterLineHighlightsToggle<CR>
        nmap             -          <Plug>GitGutterPrevHunk
        nmap             =          <Plug>GitGutterNextHunk
        nmap     <Leader>ggw        <Plug>GitGutterStageHunk
        nmap     <Leader>ggu        <Plug>GitGutterUndoHunk
        nmap     <Leader>ggd        <Plug>GitGutterPreviewHunk
        " replace the `=` mapping
        nnoremap <Leader>=          =
    " }}}2

    " editorconfig-vim {{{2
        let g:EditorConfig_exec_path = $BREW . '/bin/editorconfig'
    " }}}2

    " go {{{2
        let g:go_auto_type_info      = 1
        let g:go_highlight_operators = 1
        let g:go_highlight_functions = 1
        let g:go_highlight_methods   = 1
        let g:go_highlight_structs   = 1
    " }}}2

    " neoterm {{{2
        if has('nvim')
            let g:test#strategy    = 'neoterm'  " run tests with :T
            let g:neoterm_position = 'vertical' " vertical split
        endif
    " }}}2

    " plasticboy/vim-markdown {{{2
        if has('nvim')
            let g:markdown_fold_style             = 'nested'
            let g:markdown_fold_override_foldtext = 0
        endif
    " plasticboy/vim-markdown }}}2
" Plugin Settings }}}1


" Define Plugins {{{1
    call plug#begin('~/.vim/bundle')
    function! PIf(cond, ...)
        let l:opts = get(a:000, 0, {})
        return a:cond ? l:opts : extend(l:opts, { 'on': [], 'for': [] })
    endfunction

    Plug 'chriskempson/base16-vim'
    Plug 'tmux-plugins/vim-tmux-focus-events'    , PIf(!empty($TMUX)) |
        \ Plug 'christoomey/vim-tmux-navigator'  , PIf(!empty($TMUX))

    call plug#end()
" Plugins }}}1


" Initialize Vim {{{1
    if has('termguicolors')
        set termguicolors
    endif

    " do CursorLine stuff before `:colorsc` or `:set background`
    try
        let g:base16colorspace  = 256
        let g:base16_shell_path = $BASE16_SHELL.'/scripts'
        if filereadable(expand('~/.vimrc_background'))
            source ~/.vimrc_background
        endif
    catch
        try
            colorscheme jellybeans
        catch /^Vim(colorscheme):E185/
            colorscheme desert
        endtry
    endtry
" Initialize Vim }}}1


" vimpager Settings {{{
    " V1
    let g:vimpager         = {}
    let g:less             = {}
    let g:vimpager.X11     = 0
    let g:vimpager.ansiesc = 1
    let g:less.number      = 1
    " V2
    let g:vimpager_use_gvim        = 0
    let g:vimpager_disable_x11     = 1
    let g:vimpager_passthrough     = 1
    let g:vimpager_disable_ansiesc = 1
    " key mappings
    unmap v
    unmap y
" Settings }}}
