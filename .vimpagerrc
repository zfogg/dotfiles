" {{{1 vim: filetype=vim:
" AUTHOR: Zach Fogg <me@zfo.gg>
" DEPENDS:
"   VIM:      >= 7.4
"   VIMPAGER: >= 2.06
" }}}1 `modeline`


" {{{1 Basic Settings
    set number                  " display line numbers
    set numberwidth=1           " numberglyphs use only one column
    set title                   " show file title in console title bar
    set wildmenu                " menu completion in command mode on <Tab>
    set showtabline=1           " show buffer tabs when more than one
    set pastetoggle=<F1>        " for 'Insert' mode pasting with <S-Insert>
    set history=8192            " persist mode-cmdline history
    set wildmode=full           " <Tab> cycles between all matching choices.
    set noerrorbells visualbell " no system bell, no screen blink on error

    if !has('nvim')
        set nocompatible        " vim > vi
        set t_vb=               " no system bell, no screen blink on error
    endif

    if has("unnamedplus") " X11 support
        set clipboard+=unnamedplus
    endif

    let s:dotfiles   = exists('$DOTFILES') ? $DOTFILES : '.dotfiles'
    let s:dotvim     = exists('$DOTVIM')   ? $DOTVIM   : s:dotfiles.'/.vim'
    let s:dotfiles_f = expand(s:dotfiles)
    let s:dotvim_f   = expand(s:dotvim)
    let s:dotfiles_r = fnamemodify(s:dotfiles, ':~')
    let s:dotvim_r   = fnamemodify(s:dotvim,   ':~')

    let s:myvimrc   = s:dotvim  .'/vimrc'
    let s:myvimrc_f = s:dotvim_f.'/vimrc'
    let s:myvimrc_r = s:dotvim_r.'/vimrc'

    " {{{2 undo / redo, swap, backup
        let s:dotvim_dotdirs = {}
        for [s:dir_name, s:dir_path] in items({
            \ 'undo'   : '.undo',
            \ 'swap'   : '.swap',
            \ 'backup' : '.backup',
        \ })
            let s:dir = s:dotvim_f.'/'.s:dir_path
            if !isdirectory(s:dir) | call mkdir(s:dir) | endif
            let s:dotvim_dotdirs[s:dir_name] = s:dir[1:]
        endfor

        if !exists('g:mytmpdir')
            let g:mytmpdir = system('echo -n "${TMPDIR%/}"')
        endif

        function! MyTmpdirs(pree, post, ...)
            let l:pree = exists('a:pree') ? a:pree : ''
            let l:post = exists('a:post') ? a:post : ''
            let l:pre_dirs = a:0 > 0
                \ ? map(copy(a:000), 'l:pree . v:val . l:post')
                \ : []
            let l:std_dirs = [
                \          g:mytmpdir    . l:post,
                \ l:pree . 'private/tmp' . l:post,
                \ l:pree . 'var/tmp'     . l:post,
                \ l:pree . 'tmp'         . l:post,
            \ ]
            let l:out_dirty = join(l:pre_dirs + l:std_dirs, ',')
            return escape(l:out_dirty, '\')
        endfunction

        " wildignore
        set wildignore+=*.o,*.obj,*.so,,*.exe,*.dll,*.manifest,*.dmg
        set wildignore+=*.swp,*.pyc,*.class
        set wildignore+=*.tar,*.bz,*.gz,*.xz,*.zip
        set wildignore+=*~

        " {un,re}do history
        let &undodir = MyTmpdirs('/', '', s:dotvim_dotdirs['undo'])
        set undofile

        " swapfiles
        let &directory = MyTmpdirs('/', '//', s:dotvim_dotdirs['swap'])

        " backups
        let &backupdir  = MyTmpdirs('/', '', s:dotvim_dotdirs['backup'])
        let &backupskip = MyTmpdirs('/', '/*',
            \ s:dotvim_dotdirs['undo'],
            \ s:dotvim_dotdirs['swap'],
            \ s:dotvim_dotdirs['backup'],
        \ )
        set backupskip=&backupskip
    " }}}2 undo / redo, swap, backup

    " {{{2 Moving around and editing
        set nostartofline           " Avoid moving cursor to BOL when jumping around.
        set virtualedit=all         " Let cursor move past $ in command mode.
        set backspace=2             " Allow backspacing over autoindent, EOL, and BOL.
        set autoindent              " Always set autoindenting on.
        set lazyredraw              " For better macro performance.
    " }}}2 Moving around and editing

    " {{{2 Tiny aesthetic tweaks
        set cursorline              " A horizontal line for the cursor location.
        set ruler                   " Show the cursor position all the time.
        set scrolloff=3             " Keep n context lines above and below the cursor.
        set showmatch               " Briefly jump to a paren once it's balanced.
        set list                    " Visually display tabs and trailing whitespace.
        set listchars=trail:·,tab:·\ ,eol:¬,extends:>,precedes:<
    " }}}2 Tiny aesthetic tweaks

    " Whitespace {{{2
        set shiftwidth=4            " An indent level is n spaces.
        set expandtab               " Use spaces, not tabs, for autoindent/tab key.
        set tabstop=4               " <Tab> inserts n spaces.
        set softtabstop=4           " <BS> over an autoindent deletes both spaces.
        set shiftround              " Rounds indent to a multiple of shiftwidth.
        set linebreak               " Don't wrap textin the middle of a word.
        let &showbreak = '\\ '      " Visualize wrapped lines.
        set nowrap                  " Don't wrap text.
        set textwidth=0             " Don't break lines.
        set wrapmargin=0            " Seriously, don't break lines.
    " }}}2

    " Folding. {{{2
        set foldenable
        set foldmethod=syntax
        set foldopen=mark,percent,quickfix,tag,undo
    " }}}2

    " Reading and writing. {{{2
        set noautowrite             " Never write a file unless I request it.
        set noautowriteall          " NEVER.
        set noautoread              " Don't automatically re-read changed files.
        set modeline                " Allow vim options to be embedded in files;
        set modelines=3             " they must be within the first or last 5 lines.
        set ffs=unix,dos,mac        " Try recognizing dos, unix, and mac line endings.
    " }}}2

    " Messages, info, and statuses. {{{2
        set shortmess=aOstTI             " :help 'shortmess'
        set laststatus=2                " allways show status line
        set confirm                     " Y-N-C prompt if closing with unsaved changes.
        set showcmd                     " Show incomplete normal mode commands as I type.
        set report=0                    " : commands always print changed line count.
        set ruler                       " Show some info, even without statuslines.
        set laststatus=2                " Always show statusline, even if only 1 window.
        "set statusline=%<%f\ %h%m%r%{fugitive#statusline()}%=%-14.(%l,%c%V%)\ %P
    " }}}2

    " Searching and Patterns {{{2
        set ignorecase              " Default to using case insensitive searches.
        set smartcase               " unless uppercase letters are used in the regex.
        set smarttab                " Handle tabs more intelligently.
        set hlsearch                " Highlight searches by default.
        set incsearch               " Incrementally search while typing a /regex.
    " }}}2

    " The 'Session' plugin does this on save.
    set sessionoptions-=blank
    set sessionoptions-=options
    set sessionoptions-=buffers

    " Per-project .vimrc.
    set exrc
    set secure

    " Faster CursorHold aucmd
    set updatetime=250 " milliseconds

    " http://stackoverflow.com/a/15471820
    if $TERM =~ '^\(screen\|xterm\)' && exists('$TMUX')
        set mouse+=a
    endif

    " 'text-obj' patterns for 'word' and file /path
        " NOTE: http://www.ascii-code.com/
            " '@'       == /[a-zA-Z]/ == filter(isalpha, $ascii_arr)
            " ,48-57,   == /[0-9]/    == filter(isdigit, $ascii_arr)
            " ,192-255, == /[À-ÿ]/    /* accented characters - extended ascii */
            " ,,,       == /,/
            " ,@-@,     == /@/
            " ,^,,      == /[^,]/
            " ,^<EOL>   == /\^/
        " NOTE: :help 'isfname' | :help 'iskeyword'
    set   isfname=@,48-57,#,~,$,_,-,/,.,+,,,%,=
    set iskeyword=@,48-57,#,~,$,_,-,192-255
" }}}1 Basic Settings


" Key Mappings {{{1
    let mapleader=","

    noremap : <Nop>
    noremap ; :
    " and if you ever wanna map to ;
    "noremap ;; ;

    " write
    nnoremap <Leader>w :w<CR>
    nnoremap <Leader>W :silent! w<CR>
    cnoremap w! w !sudo tee % >/dev/null

    " quit
    nnoremap <Leader>q :q<CR>

    " vimrc
    execute 'nnoremap <silent> <Leader>v'
        \.' :$tabe'
        \.' <BAR> lcd '.s:dotfiles_r
        \.' <BAR> e '.substitute(s:myvimrc, s:dotfiles.'/', '', '')
        \.' <BAR> silent! foldo!'
        \.' <BAR> norm zz'
        \.'<CR>'
    execute 'nnoremap <silent> <Leader>V'
        \.' :source '.s:myvimrc
        \.' <Bar> filetype detect'
        \.' <Bar> redraw'
        \.' <Bar> echo "vimrc reloaded"'
        \.'<CR>'

    " Disabled default commands. {{{2
        nnoremap Q       <Nop>
        noremap  <Up>    <Nop>
        noremap  <Down>  <Nop>
        noremap  <Left>  <Nop>
        noremap  <Right> <Nop>
        inoremap <Up>    <Nop>
        inoremap <Down>  <Nop>
        inoremap <Left>  <Nop>
        inoremap <Right> <Nop>
    " }}}2

    " Yanking and pasting. {{{2
        " Copy to system clipboard.
        noremap <Leader>y "+y
        " Paste from system clipboard.
        noremap <Leader>p "+p
        " Easily yank from cursor to EOL.
        nnoremap Y y$
        " Retain " register after pasting.
        xnoremap <expr> p v:register=='"'?'pgvy':'p'
    " }}}2

    " Cursor motion. {{{2
        if empty($TMUX)
            nnoremap <C-H> <C-W>h
            nnoremap <C-J> <C-W>j
            nnoremap <C-K> <C-W>k
            nnoremap <C-L> <C-W>l
        else
            let g:tmux_navigator_no_mappings = 1
            nnoremap <silent> <C-h> :TmuxNavigateLeft<CR>
            nnoremap <silent> <C-j> :TmuxNavigateDown<CR>
            nnoremap <silent> <C-k> :TmuxNavigateUp<CR>
            nnoremap <silent> <C-l> :TmuxNavigateRight<CR>
            nnoremap <silent> <C-\> :TmuxNavigatePrevious<CR>
        end
        if has('nvim')
            let $NVIM_TUI_ENABLE_CURSOR_SHAPE = 1          " change cursor to bar in insert mode
            tnoremap <Esc> <C-\><C-n>
            tmap     <silent> jj <C-\><C-n>{}k$
            tmap     <silent> <C-h> jj<C-h>
            tmap     <silent> <C-j> jj<C-j>
            tmap     <silent> <C-k> jj<C-k>
            tmap     <silent> <C-l> jj<C-l>
        end

        " j and k just work on long wrapped lines.
        nnoremap j gj
        nnoremap k gk

        " Scroll through items in the locations list.
        nmap <Leader>< <Plug>LocationPrevious
        nmap <Leader>> <Plug>LocationNext

        " A 'scrolling' effect.
        " FIXME: doesn't really work with in my iTerm+tmux setup.
        " nnoremap <a-j> <c-e>j
        " nnoremap <a-k> <c-y>k
        " nnoremap <a-l> zll
        " nnoremap <a-h> zhh

        " think of your left pinky
        inoremap jj <Esc>
        inoremap kk <Esc>:w<CR>

        " Leaving `Insert-mode` is too much sometimes.
        inoremap HH <C-o>^
        inoremap LL <C-o>$

        " Jump to matching pairs easily with tab.
        vnoremap <Tab> %
    " }}}2

    " Folds. {{{2
        nnoremap <Space> za
        vnoremap <Space> za
    " }}}2

    " Tabs and splits. {{{2
        nnoremap <Leader><C-t> :tabnew<CR>
        nnoremap <Leader>x     :tabclose<CR>
        nnoremap <Leader>j     :tabprevious<CR>
        nnoremap <Leader>k     :tabnext<CR>
        " Resize splits.
        nnoremap <S-Up>    5<C-W>+
        nnoremap <S-Down>  5<C-W>-
        nnoremap <S-Right> 5<C-W>>
        nnoremap <S-Left>  5<C-W><
        nnoremap   <Up>     <C-W>+
        nnoremap   <Down>   <C-W>-
        nnoremap   <Right>  <C-W>>
        nnoremap   <Left>   <C-W><
    " }}}2

    " :make. {{{2
        "nnoremap <Leader>M  :silent! make<CR>:redraw!<CR>
        "nnoremap <Leader>Mc :silent! make clean<CR>:redraw!<CR>
        "nnoremap <Leader>Mm :silent! make clean all<CR>:redraw!<CR>
        "nnoremap <Leader>Mt :cclose \| silent! make test           \| copen<CR>:AnsiEsc<CR>G:redraw!<CR>
        "nnoremap <Leader>MT :cclose \| silent! make clean all test \| copen<CR>:AnsiEsc<CR>G:redraw!<CR>
    " }}}

    " Et cetera. {{{2
        " Previous matching command or search.
        cnoremap kk <Up>

        " Enter Replace mode from Visual mode.
        vnoremap R r<Space>R

        " Don't let `single-repeat` disturb the cursor's location.
        nnoremap . .`[

        " Delete trailing whitespace.
        nnoremap <Leader>S :%s/\s\+$//<cr>:let @/=''<CR><c-o>

        " Fixes for display glitches.
        nnoremap <silent> <Leader><Space> :nohlsearch<C-R>=has('diff')?'<Bar>diffupdate':''<CR><CR>,<Space>
        nnoremap <Leader>rd :redraw!<CR>

        " Set the background to transparent.
        "nnoremap <Leader>bg :hi Normal ctermbg=NONE<CR>

        " Change to the directory of the current buffer's file.
        nnoremap <Leader>lcd :lcd %:p:h<CR>
        nnoremap <Leader>cd  :cd  %:p:h<CR>

        " omnicomplete
        "imap </            <C-_>
        "nnoremap <Leader>/ <C-_>
    " }}}2
" Key Mappings }}}1


" Plugin Settings {{{1
    " NERDTree {{{2
        let NERDTreeWinPos    = "right"
        let NERDTreeMinimalUI = 1
        let NERDTreeIgnore    = [
            \ ''  . '\~'               . '$' . '[[file]]' ,
            \ ''  . '\~'               . '$' . '[[dir]]'  ,
            \ '^' . '\.git'            . '$' . '[[dir]]'  ,
            \ '^' . '\.hg'             . '$' . '[[dir]]'  ,
            \ '^' . '\.svn'            . '$' . '[[dir]]'  ,
            \ '^' . 'node_modules'     . '$' . '[[dir]]'  ,
            \ '^' . 'bower_components' . '$' . '[[dir]]'  ,
            \ ''  . '\.o'              . '$' . '[[file]]' ,
            \ ''  . '\.obj'            . '$' . '[[file]]' ,
            \ ''  . '\.so'             . '$' . '[[file]]' ,
            \ ''  . '\.exe'            . '$' . '[[file]]' ,
            \ ''  . '\.dmg'            . '$' . '[[file]]' ,
            \ ''  . '\.swap'           . '$' . '[[file]]' ,
            \ ''  . '\.class'          . '$' . '[[file]]' ,
            \ ''  . '\.pyc'            . '$' . '[[file]]' ,
            \ ''  . '\.tar'            . '$' . '[[file]]' ,
            \ ''  . '\.bz'             . '$' . '[[file]]' ,
            \ ''  . '\.gz'             . '$' . '[[file]]' ,
            \ ''  . '\.xz'             . '$' . '[[file]]' ,
            \ ''  . '\.zip'            . '$' . '[[file]]' ,
        \ ]
        " key bindings
        nnoremap <Leader>n<Space> :NERDTreeToggle<CR>
    " }}}2

    " NERDCommenter {{{2
        let NERDMenuMode               = 1
        let NERDSpaceDelims            = 0
        let NERDRemoveExtraSpaces      = 1
        let NERDCompactSexyComs        = 1
        let NERDAlignDefault           = "both"
        let NERDTrimTrailingWhitespace = 1
        " `&filetype` settings
        let g:NERDAltDelims_haskell    = 1
    " }}}2

    " Fugitive. {{{2
        " key bindings
        nmap <Leader>gc :Gcommit<CR>
        nmap <Leader>gd :Gdiff<CR>
        nmap <Leader>gl :Glog<CR>
        nmap <Leader>gs :Gstatus<CR>
        nmap <Leader>gR :Gread<CR>
        nmap <Leader>gW :Gwrite<CR>:e<CR>
        nmap <Leader>gp :Git push<CR>
        nmap <Leader>gb :Gblame<CR>
        nmap <Leader>gH :Gbrowse<CR>
    " }}}2

    " IndentGuides {{{2
        let g:indent_guides_start_level           = 2
        let g:indent_guides_guide_size            = 1
        let g:indent_guides_enable_on_vim_startup = 1
        let g:indent_guides_auto_colors           = 0
        function! <SID>SetIndentGuideColors()
            hi clear IndentGuidesOdd
            hi clear IndentGuidesEven
            hi IndentGuidesOdd  ctermbg=19 guibg=#383838
            hi IndentGuidesEven ctermbg=08 guibg=#585858
        endfunction
        augroup IndentGuides
            au!
            au! VimEnter,Colorscheme * :call <SID>SetIndentGuideColors()
        augroup END
    " }}}2

    " Rainbow Parentheses {{{2
        let g:rainbow_active = 1
        let g:rainbow_conf = {
            \ 'operators': '_,_',
            \ 'parentheses': [
                \ 'start=/(/  end=/)/  fold',
                \ 'start=/\[/ end=/\]/ fold',
                \ 'start=/{/  end=/}/  fold',
            \ ],
            \ 'guifgs': [
                \ 'royalblue3',
                \ 'darkorange3',
                \ 'seagreen3',
                \ 'firebrick',
            \ ],
            \ 'ctermfgs': [
                \ 'lightblue',
                \ 'lightyellow',
                \ 'lightcyan',
                \ 'lightmagenta',
            \ ],
            \ 'separately': {
                \ '*': {},
                \ 'css': 0,
                \ 'phony.example': {
                    \ 'operators'   : '',
                    \ 'parentheses' : [],
                    \ 'guifgs'      : [],
                    \ 'ctermfgs'    : [],
                \ },
                \ 'vim': {
                    \ 'parentheses': [
                        \ 'start=/(/  end=/)/',
                        \ 'start=/\[/ end=/\]/',
                        \ 'start=/{/  end=/}/  fold',
                        \ 'start=/(/  end=/)/       containedin=vimFuncBody',
                        \ 'start=/\[/ end=/\]/      containedin=vimFuncBody',
                        \ 'start=/{/  end=/}/  fold containedin=vimFuncBody',
                    \ ],
                \ },
                \ 'html': {
                    \ 'parentheses': [
                        \ 'start=/\v\<((area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)[ >])@!\z([-_:a-zA-Z0-9]+)(\s+[-_:a-zA-Z0-9]+(\=("[^"]*"|'."'".'[^'."'".']*'."'".'|[^ '."'".'"><=`]*))?)*\>/ end=#</\z1># fold'
                    \ ],
                \ },
            \ }
        \ }
        " key bindings
        "nnoremap <Leader>rp<Space> :RainbowParenthesesToggleAll<CR>
    " }}}2

    " YouCompleteMe {{{2
        let g:ycm_autoclose_preview_window_after_completion = 1
        let g:ycm_autoclose_preview_window_after_insertion  = 1
        let g:ycm_register_as_syntastic_checker             = 0
        let g:ycm_complete_in_comments                      = 1
        let g:ycm_seed_identifiers_with_syntax              = 1
        let g:ycm_collect_identifiers_from_tags_files       = 0
        "let g:ycm_extra_conf_globlist                       = ['~/src/*']
        "let g:ycm_semantic_triggers =  {
            "\ 'c,objc'                    : ['->', '.'],
            "\ 'cpp,objcpp'                : ['->', '.', '::'],
            "\ 'haskell'                   : ['.'],
            "\ 'java'                      : ['.'],
            "\ 'javascript,javascript.jsx' : ['.'],
            "\ 'ocaml'                     : ['.',  '#'],
            "\ 'php'                       : ['-,', '::'],
            "\ 'python'                    : ['.'],
            "\ 'vim'                       : ['.'],
        "\ }
        let g:ycm_filetype_blacklist = {
            \ 'tagbar'   : 1,
            \ 'qf'       : 1,
            \ 'notes'    : 1,
            \ 'markdown' : 1,
            \ 'unite'    : 1,
            \ 'text'     : 1,
            \ 'vimwiki'  : 1,
            \ 'pandoc'   : 1,
            \ 'infolog'  : 1,
            \ 'mail'     : 1
        \ }
        " key bindings
        let g:ycm_key_list_select_completion   = ['<C-n>', '<Down>']
        let g:ycm_key_list_previous_completion = ['<C-p>', '<Up>']
        let g:SuperTabDefaultCompletionType    = '<C-n>'
    " }}}2

    " Ag {{{2
        if executable('ag')
            let g:ag_prg    = 'ag --vimgrep --nogroup --hidden -p '.$HOME.'/.agignore $*'
            let &grepprg    = g:ag_prg
            let &grepformat = '%f:%l:%c:%m'
        else
            let &grepprg = 'grep --color=never -e --exclude-dir .git -nrI $* . /dev/null'
        endif
    " Ag }}}2

    " C trlP {{{2
        let g:ctrlp_map               = '<C-p>'
        let g:ctrlp_cmd               = 'CtrlP'
        let g:ctrlp_root_markers      = ['.git',  '.hg', '.svn']
        let g:ctrlp_working_path_mode = 'ra'
        let g:ctrlp_cache_dir         = $HOME.'/.cache/ctrlp'
        let g:ctrlp_extensions        = ['mixed', 'tag', 'line', 'dir', 'commandline']
        let g:ctrlp_custom_ignore = {
          \ 'dir':  '\v[\/]\.(git|hg|svn)$',
          \ 'file': '\v\.(exe|so|dll)$',
          \ 'link': 'SOME_BAD_SYMBOLIC_LINKS',
          \ }
        let g:ctrlp_user_command = {
            \ 'types': {
                \ 1: ['.git', 'cd %s && git ls-files -co --exclude-standard'],
            \ },
        \ }
        " key bindings
        "nmap <C-p> <Plug>CtrlP
        "nmap <C-f> <Plug>CtrlPLine
    " }}}2

    " {{{2 EasyMotion
        "let g:EasyMotion_leader_key = '<Leader>'
        "nnoremap <Leader><Leader> <Plug>(easymotion-prefix)
    " }}}2 EasyMotion

    " EasyAlign{{{2
        nmap ga <Plug>(EasyAlign)
        xmap ga <Plug>(EasyAlign)
        let g:easy_align_ignore_groups          = ['Comment', 'String']  "[]
        let g:easy_align_interactive_modes      = ['l', 'r', 'c']        "['l', 'r', 'c']
        let g:easy_align_bang_interactive_modes = ['r', 'l', 'c']        "['r', 'l', 'c']
    " }}}2

    " Lightline {{{2
        let g:lightline = {
            \ 'colorscheme': 'jellybeans',
            \ 'separator'    : { 'left': '', 'right': '' },
            \ 'subseparator' : { 'left': '', 'right': '' },
            \ 'active': {
                \ 'left': [
                    \ ['mode', 'paste'],
                    \ ['fugitive', 'filename'],
                    \ ['ctrlpmark'],
                \ ],
                \ 'right': [
                    \ ['percent'],
                    \ ['fileformat', 'fileencoding', 'filetype'],
                \ ],
            \ },
            \ 'component_function': {
                \ 'readonly'     : 'LightLineReadonly',
                \ 'modified'     : 'LightLineModified',
                \ 'fugitive'     : 'LightLineFugitive',
                \ 'filename'     : 'LightLineFilename',
                \ 'fileformat'   : 'LightLineFileformat',
                \ 'filetype'     : 'LightLineFiletype',
                \ 'fileencoding' : 'LightLineFileencoding',
                \ 'mode'         : 'LightLineMode',
                \ 'ctrlpmark'    : 'CtrlPMark',
            \ },
        \ }

        function! LightLineReadonly()
            if &ft == 'help' | return ''
            elseif &readonly | return '🔒'
            else             | return '' | endif
        endfunction

        function! LightLineModified()
            if &ft == 'help'   | return ''
            elseif &modified   | return '+'
            elseif &modifiable | return '-'
            else               | return '' | endif
        endfunction

        function! LightLineFugitive()
            try
                if expand('%:t') !~? 'Tagbar\|Gundo\|NERD' && &ft !~? 'vimfiler' && exists('*fugitive#head')
                let branch = fugitive#head()
                return branch !=# '' ? ' ' . branch : ''
                endif
            catch
            endtry
            return ''
        endfunction

        function! LightLineFilename()
            let fname = expand('%:t')
            if fname == 'ControlP' && has_key(g:lightline, 'ctrlp_item')
                return g:lightline.ctrlp_item
            elseif fname =~ 'NERD_tree' | return ''
            else
                return ('' != LightLineReadonly() ?       LightLineReadonly() . ' ' : '') .
                    \  ('' != fname ? expand('%:h:t').'/'.fname : '[No Name]') .
                    \  ('' != LightLineModified() ? ' ' . LightLineModified()       : '')
            endif
        endfunction

        function! LightLineFileformat()
            return winwidth(0) > 70 ? &fileformat : ''
        endfunction

        function! LightLineFiletype()
            return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
        endfunction

        function! LightLineFileencoding()
            return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
        endfunction

        function! LightLineMode()
            let fname = expand('%:t')
            return fname == 'ControlP' ? 'CtrlP' :
                \ fname =~ 'NERD_tree' ? 'NERDTree' :
                \ winwidth(0) > 60 ? lightline#mode() : ''
        endfunction

        function! CtrlPMark()
            if expand('%:t') =~ 'ControlP' && has_key(g:lightline, 'ctrlp_item')
                call lightline#link('iR'[g:lightline.ctrlp_regex])
                return lightline#concatenate([
                    \ g:lightline.ctrlp_prev,
                    \ g:lightline.ctrlp_item,
                    \ g:lightline.ctrlp_next,
                \ ], 0)
            else | return '' | endif
        endfunction

        let g:ctrlp_status_func = {
            \ 'main': 'CtrlPStatusFunc_1',
            \ 'prog': 'CtrlPStatusFunc_2',
        \ }
        function! CtrlPStatusFunc_1(focus, byfname, regex, prev, item, next, marked)
            let g:lightline.ctrlp_regex = a:regex
            let g:lightline.ctrlp_prev  = a:prev
            let g:lightline.ctrlp_item  = a:item
            let g:lightline.ctrlp_next  = a:next
            return lightline#statusline(0)
        endfunction
        function! CtrlPStatusFunc_2(str)
            return lightline#statusline(0)
        endfunction
    " }}}2

    " Neomake {{{2
        hi link NeomakeErrorSign   NeomakeErrorSignDefault
        hi link NeomakeWarningSign NeomakeWarningSignDefault
        augroup Neomake
            autocmd!
            " autocmd ColorScheme *
                " \ hi NeomakeErrorSign   ctermfg=red    guifg=red |
                " \ hi NeomakeWarningSign ctermfg=yellow guifg=yellow
            " autocmd! BufWritePost * Neomake
        augroup END
    " }}}2

    " Chromatica {{{2
        "let g:chromatica#libclang_path='/usr/local/opt/llvm/lib'
    " }}}2

    " Session {{{2
        let g:session_default_name      = 'default'           " When you don't name your session.
        let g:session_command_aliases   = 1                   " Use commands prefixed with 'Session'.
        let g:session_autosave          = 'yes'               " Save on exit sans prompt.
        let g:session_autosave_periodic = 2                   " Save every 'n' minutes.
        let g:session_autoload          = 0                   " Don't ask to open default session.
        let g:session_verbose_messages  = 0                   " Disable noisy save messages.
        let g:session_persist_globals   = ['&sessionoptions'] " Persist `vim-session` plugin opts
        call add(g:session_persist_globals, 'g:session_autosave')
        call add(g:session_persist_globals, 'g:session_autosave_periodic')
        call add(g:session_persist_globals, 'g:session_autoload')
        call add(g:session_persist_globals, 'g:session_default_to_last')
        call add(g:session_persist_globals, 'g:session_persist_globals')
        nnoremap <Leader>So :OpenSession<CR>
        nnoremap <Leader>Ss :SaveSession<CR>
        nnoremap <Leader>Sq :SaveSession<CR>:CloseSession<CR>
        nnoremap <Leader>SQ <Leader>Sq:q<CR>
    " }}}2

    " gitgutter {{{2
        let g:gitgutter_enabled         = 1
        let g:gitgutter_map_keys        = 1
        let g:gitgutter_highlight_lines = 0
        let g:gitgutter_async           = 1
        let g:gitgutter_realtime        = 1
        let g:gitgutter_eager           = 1
        let g:gitgutter_diff_args       = '-w'
        let g:gitgutter_max_signs       = 1024
        "let g:gitgutter_grep_command    = &grepprg
        " key bindings
        nnoremap <Leader>gg<Space>  :GitGutterToggle<CR>
        nnoremap <Leader>ggl<Space> :GitGutterLineHighlightsToggle<CR>
        nmap             -          <Plug>GitGutterPrevHunk
        nmap             =          <Plug>GitGutterNextHunk
        nmap     <Leader>ggw        <Plug>GitGutterStageHunk
        nmap     <Leader>ggu        <Plug>GitGutterUndoHunk
        nmap     <Leader>ggd        <Plug>GitGutterPreviewHunk
        " replace the `=` mapping
        nnoremap <Leader>=          =
    " }}}2

    " editorconfig-vim {{{2
        let g:EditorConfig_exec_path = $BREW . '/bin/editorconfig'
    " }}}2

    " localvimrc {{{2
        let g:localvimrc_ask     = 0
        let g:localvimrc_sandbox = 0
    " }}}2

    " go {{{2
        let g:go_auto_type_info      = 1
        let g:go_highlight_operators = 1
        let g:go_highlight_functions = 1
        let g:go_highlight_methods   = 1
        let g:go_highlight_structs   = 1
    " }}}2

    " quick-scope {{{2
        "let g:qs_enable = 0
        "nnoremap <C-_> :normal ,<CR>
        "vnoremap <C-_> :normal ,<CR>
        "function! Quick_scope_selective(movement)
            "let needs_disabling = 0
            "if !g:qs_enable
                "QuickScopeToggle
                "redraw
                "let needs_disabling = 1
            "endif
            "let letter = nr2char(getchar())
            "if needs_disabling
                "QuickScopeToggle
            "endif
            "return a:movement . letter
        "endfunction
        " key bindings
        "nnoremap <expr> <silent> f Quick_scope_selective('f')
        "nnoremap <expr> <silent> F Quick_scope_selective('F')
        "nnoremap <expr> <silent> t Quick_scope_selective('t')
        "nnoremap <expr> <silent> T Quick_scope_selective('T')
        "vnoremap <expr> <silent> f Quick_scope_selective('f')
        "vnoremap <expr> <silent> F Quick_scope_selective('F')
        "vnoremap <expr> <silent> t Quick_scope_selective('t')
        "vnoremap <expr> <silent> T Quick_scope_selective('T')
    " }}}2

    " neoterm {{{2
        if has('nvim')
            let test#strategy      = "neoterm"  " run tests with :T
            let g:neoterm_position = "vertical" " vertical split
        endif
    " }}}2
" Plugin Settings }}}1


" Define Plugins {{{1
  call plug#begin('~/.vim/bundle')
  function! PCond(cond, ...)
    let opts = get(a:000, 0, {})
    return a:cond ? opts : extend(opts, { 'on': [], 'for': [] })
  endfunction

  Plug 'chriskempson/base16-vim'
  Plug 'tmux-plugins/vim-tmux', { 'for': 'tmux' }
  Plug 'tmux-plugins/vim-tmux-focus-events'
  Plug 'christoomey/vim-tmux-navigator', PCond(!empty($TMUX))

  call plug#end()
" Plugins }}}1


" FileType Settings {{{1
    augroup AllFiles
        au!
        " Return cursor to last position.
        au! BufReadPost *
            \ if ! exists("g:leave_my_cursor_position_alone")      |
            \   let g:cursor_line = line("'\"")                    |
            \   if g:cursor_line > 0 && g:cursor_line <= line("$") |
            \     exe "normal g'\""                                |
            \   endif                                              |
            \ endif
    augroup END

    augroup C_Cpp
        au!
        "au BufWritePost *.c,*.cpp,*.h,*.hpp silent YcmDiags
    augroup END

    augroup JSON
        au!
        au BufRead,BufNewFile .eslintrc,.babelrc set ft=json
    augroup END
" Filetype Settings }}}1


" Initialize Vim {{{1
    call plug#end()

    if has('nvim')
        let $NVIM_TUI_ENABLE_TRUE_COLOR="1"
    endif

    if has('termguicolors')
        set termguicolors
    endif

    " do CursorLine stuff before `:colorsc` or `:set background`
    function! <SID>SetCursorLine()
        hi clear CursorLine
        hi CursorLineNR term=bold cterm=bold ctermfg=white gui=bold guifg=white
    endfunction
    call <SID>SetCursorLine()
    augroup CursorLine
        au!
        au! ColorScheme * :call <SID>SetCursorLine()
    augroup END

    try
        let base16colorspace=256
        let g:base16_shell_path=$BASE16_SHELL.'/scripts'
        set background=dark
        if filereadable(expand("~/.vimrc_background"))
            source ~/.vimrc_background
        endif
    catch
        try
            colorscheme jellybeans
        catch /^Vim\%((\a\+)\)\=:E185/
            colorscheme desert
        endtry
    endtry
" Initialize Vim }}}1


" vimpager Settings {{{
    " V1
    let g:vimpager         = {}
    let g:less             = {}
    let g:vimpager.X11     = 0
    let g:vimpager.ansiesc = 1
    let g:less.number      = 1
    " V2
    let g:vimpager_use_gvim        = 0
    let g:vimpager_disable_x11     = 1
    let g:vimpager_passthrough     = 1
    let g:vimpager_disable_ansiesc = 1
    " key mappings
    unmap v
    unmap y
" Settings }}}
